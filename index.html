<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <title>회진 차트</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --gap: 12px;
      --border: #ddd;
      --bg: #fafafa;
      --muted: #666;
      --accent: #0a7;
      --header-h: 0px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
      margin: 0;
      color: #111;
    }

    header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: var(--bg);
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    header h1 {
      font-size: 18px;
      margin: 0 8px 0 0;
    }

    .filebar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .filebar label {
      font-size: 13px;
      color: #333;
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
    }

    .btn {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }

    .btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    .grid {
      display: grid;
      grid-template-columns: 260px 1fr 1fr 1fr;
      gap: var(--gap);
      padding: var(--gap);
    }

    .panel {
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 300px;
    }

    .panel h3 {
      margin: 0;
      padding: 8px 12px;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      font-size: 14px;
    }

    .panel .body {
      padding: 10px;
      overflow: visible;
      flex: 1;
    }

    #previewBody {
      overflow: visible;
    }

    .patient-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .group {
      margin-bottom: 10px;
    }

    .group .ghead {
      font-weight: 700;
      font-size: 13px;
      margin: 8px 0 6px;
      color: #222;
    }

    .pill {
      font-size: 12px;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      background: #fff;
    }

    .pill.active {
      outline: 2px solid var(--accent);
    }

    .pill .muted {
      color: #777;
    }

    .pill.new {
      background: #e6ffed;
      border-color: #b7e4c7;
    }

    /* 신환 = 초록 */
    .pill.existing {
      background: #fff;
    }

    .pill.discharged {
      background: #f3f3f3;
    }

    .pill.done {
      opacity: .6;
    }

    .pill .right {
      margin-left: auto;
      display: flex;
      gap: 6px;
      align-items: center;
    }

    textarea.input {
      width: 100%;
      min-height: 240px;
      height: auto;
      resize: vertical;
      overflow: hidden;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }

    pre.code {
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      background: #fcfcfc;
      border: 1px dashed var(--border);
      padding: 8px;
      border-radius: 6px;
    }

    .tray {
      border-top: 1px dashed var(--border);
      margin-top: 8px;
      padding-top: 6px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    small {
      color: #666;
    }

    .footer {
      padding: 10px;
      border-top: 1px solid var(--border);
      background: #fff;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .badge {
      font-size: 11px;
      background: #eef;
      color: #334;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #ccd;
    }

    .hint {
      color: #444;
      font-size: 12px;
    }

    .status {
      margin: 8px 16px 0;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      display: none;
    }

    .status.ok {
      display: block;
      background: #e8fff2;
      border: 1px solid #b6f3cf;
      color: #064;
    }

    .status.err {
      display: block;
      background: #fff1f1;
      border: 1px solid #f5bcbc;
      color: #600;
    }

    .mini-label {
      display: block;
      font-size: 12px;
      color: #333;
      margin: 8px 0 4px;
    }

    .visually-hidden-file {
      position: absolute;
      left: -9999px;
      top: auto;
      width: 1px;
      height: 1px;
      opacity: 0;
      overflow: hidden;
    }

    .mini-input {
      width: 100%;
      min-height: 140px;
      height: auto;
      resize: vertical;
      overflow: hidden;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }

    .mini-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    /* ===== 고급계산 모달 ===== */
    .calc-grid {
      display: grid;
      grid-template-columns: 220px 1fr 1fr 1.2fr;
      gap: 12px;
      height: 100%;
    }

    .calc-pane {
      border: 1px solid var(--border);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 200px;
    }

    .calc-pane .head {
      background: #f7f7f7;
      border-bottom: 1px solid var(--border);
      padding: 8px 10px;
      font-weight: 700;
      font-size: 13px;
    }

    .calc-pane .body {
      padding: 8px;
      overflow: auto;
      flex: 1;
    }

    .calc-sid .body {
      padding: 6px;
    }

    .calc-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .calc-item {
      font-size: 13px;
      text-align: left;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
    }

    .calc-item.active {
      outline: 2px solid var(--accent);
    }

    .tabbar {
      display: flex;
      gap: 6px;
      padding: 6px;
      border-bottom: 1px dashed var(--border);
      background: #fafafa;
    }

    .tabbar .tab {
      padding: 6px 10px;
      font-size: 12px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: #fff;
      cursor: pointer;
    }

    .tabbar .tab.active {
      background: #eef;
      border-color: #cdd;
    }

    .calc-kv {
      display: grid;
      grid-template-columns: 1.2fr 1fr 0.8fr;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
    }

    .calc-kv label {
      font-size: 12px;
      color: #333;
    }

    .calc-kv input,
    .calc-kv select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 12px;
    }

    .calc-out {
      white-space: pre-wrap;
      word-break: break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      background: #fcfcfc;
      border: 1px dashed var(--border);
      padding: 8px;
      border-radius: 6px;
    }

    .calc-foot {
      padding: 8px;
      border-top: 1px dashed var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .pill-warn {
      display: inline-block;
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid #f7b;
      background: #fff3f7;
      color: #a04;
      border-radius: 999px;
    }

    .pill-ok {
      display: inline-block;
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid #bde5bd;
      background: #edf9ed;
      color: #064;
      border-radius: 999px;
    }

    .muted-sm {
      color: #666;
      font-size: 12px;
    }

    .selbar {
      margin: 8px 16px;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
      font-size: 13px;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      position: sticky;
      top: var(--header-h);
      z-index: 999;
    }

    .selbar .tag {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #ccd;
      background: #eef;
      color: #334;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .35);
      display: none;
      z-index: 2000;
    }

    .modal.show {
      display: block;
    }

    .modal .inner {
      position: absolute;
      inset: 6% 4%;
      background: #fff;
      border-radius: 10px;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
    }

    .modal .topbar {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      background: var(--bg);
    }

    .modal .scr {
      flex: 1;
      overflow: auto;
      padding: 12px;
    }

    .pv-prof {
      font-weight: 700;
      font-size: 14px;
      margin: 16px 0 8px;
      padding: 6px 8px;
      background: #f1f1f1;
      border-radius: 6px;
    }

    .pv-card {
      border: 1px solid var(--border);
      border-radius: 8px;
      margin: 8px 0;
    }

    .pv-head {
      padding: 6px 8px;
      background: #f7f7f7;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .pvdoc {
      display: grid;
      grid-template-columns: 28% 13% 28% 16% 15%;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      background: #fff;
    }

    .pvdoc .cell {
      padding: 6px 8px;
      border-right: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 13px;
    }

    .pvdoc .cell.hdr {
      background: #f1f1f1;
      font-weight: 700;
    }

    .pvdoc .cell:nth-child(5n) {
      border-right: none;
    }

    .pvdoc textarea {
      width: 100%;
      min-height: 120px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      border: 1px dashed var(--border);
      padding: 6px;
      border-radius: 6px;
      overflow: hidden;
    }

    .mini-input {
      border: 1px solid #ccc;
      border-radius: 3px;
      padding: 4px !important;
      font-size: 12px !important;
      min-height: 24px !important;
      line-height: 1.4 !important;
      box-sizing: border-box;
      vertical-align: middle;
      resize: none;
      overflow-y: hidden;
    }

    .btn-xs {
      font-size: 11px !important;
      padding: 0 6px !important;
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 3px;
      cursor: pointer;
      height: 22px !important;
      max-height: 22px !important;
      line-height: 20px !important;
      vertical-align: middle;
    }

    .btn-xs:hover {
      background: #f0f0f0;
    }

    .v-field {
      display: flex;
      align-items: center;
      /* Prevent stretching */
      gap: 4px;
      font-size: 11px;
    }

    .vent-ctrl input {
      padding: 2px;
      font-size: 11px;
      border: 1px solid #ddd;
      border-radius: 3px;
    }

    /* Isolated Oxygen UI Styles */
    #oxyWrapper {
      margin-bottom: 10px;
      border: 1px solid #ddd;
      padding: 8px;
      border-radius: 4px;
      background: #f9f9f9;
      font-size: 12px;
    }

    .oxy-row {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
    }

    .oxy-btn-new {
      height: 24px;
      padding: 0 8px;
      font-size: 11px;
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 3px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .oxy-btn-new:hover {
      background: #f0f0f0;
    }

    .oxy-btn-new.active {
      background: #e0e0e0;
      font-weight: bold;
      border-color: #999;
    }

    .oxy-input-new {
      height: 24px;
      padding: 0 4px;
      font-size: 12px;
      border: 1px solid #ccc;
      border-radius: 3px;
      box-sizing: border-box;
      vertical-align: middle;
    }

    .oxy-label {
      font-weight: bold;
      margin-right: 4px;
    }

    .oxy-panel-new {
      display: none;
      margin-top: 8px;
      padding: 8px;
      border: 1px dashed #ccc;
      background: #fff;
      border-radius: 4px;
    }

    .v-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
    }

    .v-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .oxy-panel {
      display: flex;
      align-items: center;
      /* Critical for preventing stretch */
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }
  </style>
</head>

<body>
  <header>
    <h1>회진</h1>
    <div class="filebar">
      <label id="excelLabel" for="excelFile">엑셀(오늘)</label>
      <input id="excelFile" type="file" accept=".xlsx,.xls,.xlsm,.xlsb" class="visually-hidden-file" />
      <label id="docxLabel" for="docxFile">직전 회진표(DOCX) <small>(선택)</small></label>
      <input id="docxFile" type="file" accept=".docx" class="visually-hidden-file" />
      <button id="btnGenerate" class="btn primary" disabled>DOCX 저장</button>
      <button id="btnLivePreview" class="btn">미리보기</button>
      <button id="btnPickDir" class="btn">저장 폴더 지정(선택)</button>
    </div>
    <div class="hint"> </div>
    <div id="status" class="status"></div>
  </header>

  <div id="selbar" class="selbar" style="display:none;"></div>

  <main class="grid">
    <section class="panel" style="grid-column:1;">
      <h3>환자 리스트</h3>
      <div id="plistBody" class="body">
        <div id="patientList" class="patient-list"></div>
        <div class="tray">
          <div class="ghead">퇴원</div>
          <div id="dischargeTray" class="patient-list"></div>
        </div>
      </div>
    </section>

    <section class="panel" style="grid-column:2;">
      <h3>기존 Lab (직전 회진표)</h3>
      <div class="body">
        <div class="tray" style="border-top:none; margin-top:0; padding-top:0;">
          <label class="mini-label">진단명 (R2C1)</label>
          <textarea id="diagText" class="mini-input" placeholder="# DM&#10;# Septic shock"></textarea>

          <div class="mini-grid">
            <div>
              <label class="mini-label">V/S (R2C2)</label>
              <textarea id="vsText" class="mini-input" placeholder="BP/HR/RR/T/SpO2 등"></textarea>
            </div>
            <div>
              <label class="mini-label">칸4 (R2C4)</label>
              <textarea id="c4Text" class="mini-input" placeholder="자유 기입"></textarea>
            </div>
          </div>

          <label class="mini-label">칸5 (R2C5)</label>
          <textarea id="c5Text" class="mini-input" placeholder="자유 기입"></textarea>
        </div>
      </div>
    </section>

    <section class="panel" style="grid-column:3;">
      <h3>신규 Lab 원문 붙여넣기</h3>
      <div class="body">
        <!-- 산소/Vent UI -->
        <!-- Oxygen/Vent UI (Rebuilt) -->
        <div id="oxyWrapper">
          <div class="oxy-row">
            <span class="oxy-label">Oxygen / Ventilator</span>
          </div>
          <div class="oxy-row">
            <button class="oxy-btn-new" onclick="setOxyMode('RA')">RA</button>
            <button class="oxy-btn-new" onclick="setOxyMode('Nasal')">Nasal</button>
            <button class="oxy-btn-new" onclick="setOxyMode('RM')">RM</button>
            <button class="oxy-btn-new" onclick="setOxyMode('HFNC')">HFNC</button>
            <button class="oxy-btn-new" onclick="setOxyMode('Vent')">Vent</button>
            <button class="oxy-btn-new" onclick="setOxyMode('T-piece')">T-piece</button>
            <button class="oxy-btn-new" onclick="setOxyMode('Trach')">Trach</button>
          </div>

          <!-- Panels -->
          <div id="oxyPanel_Nasal" class="oxy-panel-new">
            <div class="oxy-row">
              Liters: <input type="number" id="oxy_nasal_l" class="oxy-input-new" style="width:60px;" value="1" min="1"
                max="6" step="1"> L
              <span id="oxy_nasal_fio2_disp" style="margin-left:8px; color:#666;">(FiO₂ -%)</span>
            </div>
          </div>

          <div id="oxyPanel_RM" class="oxy-panel-new">
            <div class="oxy-row">
              Liters: <input type="number" id="oxy_rm_l" class="oxy-input-new" style="width:60px;" value="10" min="1"
                max="15" step="1"> L
              <span id="oxy_rm_fio2_disp" style="margin-left:8px; color:#666;">(FiO₂ -%)</span>
            </div>
          </div>

          <div id="oxyPanel_HFNC" class="oxy-panel-new">
            <div class="oxy-row">
              Flow: <input type="number" id="oxy_hfnc_flow" class="oxy-input-new" style="width:60px;" value="40"
                min="10" max="80" step="5">
              FiO₂: <input type="number" id="oxy_hfnc_fio2" class="oxy-input-new" style="width:60px;" value="40"
                step="5" min="20" max="100"> %
            </div>
          </div>

          <div id="oxyPanel_Vent" class="oxy-panel-new">
            <div class="oxy-row">
              <select id="oxy_vent_mode" class="oxy-input-new" style="width:100%;">
                <option value="AC-VC">AC-VC (Volume Control)</option>
                <option value="AC-PC">AC-PC (Pressure Control)</option>
                <option value="SIMV-VC">SIMV-VC</option>
                <option value="SIMV-PC">SIMV-PC</option>
                <option value="PSV">PSV (Spont)</option>
                <option value="CPAP">CPAP</option>
                <option value="BiPAP">BiPAP (NIV)</option>
              </select>
            </div>
            <div class="v-grid">
              <div class="v-item v-fio2">FiO₂ <input type="number" id="v_fio2" class="oxy-input-new" style="width:50px;"
                  step="0.05"></div>
              <div class="v-item v-rr">RR <input type="number" id="v_rr" class="oxy-input-new" style="width:50px;">
              </div>
              <div class="v-item v-vt">VT <input type="number" id="v_vt" class="oxy-input-new" style="width:50px;">
              </div>
              <div class="v-item v-peep">PEEP <input type="number" id="v_peep" class="oxy-input-new"
                  style="width:50px;"></div>
              <div class="v-item v-ps">PS <input type="number" id="v_ps" class="oxy-input-new" style="width:50px;">
              </div>
              <div class="v-item v-pinsp">Pinsp <input type="number" id="v_pinsp" class="oxy-input-new"
                  style="width:50px;"></div>
              <div class="v-item v-ie">I:E 1:<input type="number" id="v_ie" class="oxy-input-new" style="width:40px;">
              </div>
              <div class="v-item v-ipap">IPAP <input type="number" id="v_ipap" class="oxy-input-new"
                  style="width:50px;"></div>
              <div class="v-item v-epap">EPAP <input type="number" id="v_epap" class="oxy-input-new"
                  style="width:50px;"></div>
            </div>
          </div>

          <div id="oxyPanel_Other" class="oxy-panel-new">
            <div class="oxy-row">
              Detail: <input type="text" id="oxy_other_detail" class="oxy-input-new" style="width:100%;"
                placeholder="e.g. 5L">
            </div>
          </div>

          <div class="oxy-row" style="margin-top:8px; color:blue;">
            Preview: <span id="oxyPreview" style="font-weight:bold; margin-left:4px;">-</span>
          </div>
        </div>

        <!-- I/O Target -->
        <div style="margin-bottom:10px;">
          <label class="mini-label">I/O Target (R1C5)</label>
          <div style="display:flex; gap:4px; margin-bottom:4px;">
            <button class="btn-xs" onclick="setIO('Even')">Even</button>
            <button class="btn-xs" onclick="adjustIO(100)">+100</button>
            <button class="btn-xs" onclick="adjustIO(-100)">-100</button>
            <button class="btn-xs" onclick="setIO('')">지우기</button>
          </div>
          <textarea id="ioText" class="mini-input" placeholder="I/O Target" style="min-height:40px;"></textarea>
        </div>

        <!-- ABGA (Moved to Panel 4) -->

        <label class="mini-label">신규 Lab (혈액검사) 붙여넣기</label>
        <textarea id="newLabGeneral" class="input" placeholder="CBC, Chemistry 등 일반 검사 결과"></textarea>

        <label class="mini-label" style="margin-top:8px;">ABGA (동맥혈가스) 붙여넣기</label>
        <textarea id="newLabABGA" class="input" placeholder="ABGA 결과만 따로 붙여넣으세요"></textarea>
        <div class="footer">
          <button id="btnUndo" class="btn">되돌리기</button>
          <button id="btnRemind" class="btn">랩 확인 메모 추가</button>
          <small> </small>
        </div>
      </div>
    </section>

    <section class="panel" style="grid-column:4;">
      <h3>결과 미리보기</h3>
      <div class="body" id="previewBody">
        <pre id="resultLab" class="code"></pre>
        <div class="footer" style="margin-top:6px; flex-wrap:wrap;">
          <button id="btnCalc" class="btn">고급계산</button>
        </div>
        <div style="margin-top:12px; border-top:1px dashed #ddd; padding-top:8px;">
          <label class="mini-label">기존 Lab (직전 회진표)</label>
          <textarea id="existingLabInput" class="input"
            placeholder="CBC :&#10;ANC :&#10;CRP :&#10;BUN/Cr :&#10;Na/K/Cl :&#10;TB/DB:&#10;AST/ALT:&#10;gGT/ALP :&#10;PT(INR) :&#10;TP/Alb :"
            style="min-height:200px; font-size:12px;"></textarea>

          <label class="mini-label" style="margin-top:8px;">ABGA (R1C3)</label>
          <textarea id="abgaText" class="mini-input" placeholder="pH / pCO2 / pO2 / HCO3 / BE / SaO2"
            style="min-height:80px;"></textarea>
        </div>
      </div>
    </section>

    <div id="liveModal" class="modal">
      <div class="inner">
        <div class="topbar">
          <div><b>라이브 미리보기</b> <small style="color:#555">— 여기서 편집하면 저장 파일에도 즉시 반영됩니다</small></div>
          <button id="btnClosePreview" class="btn">닫기</button>
        </div>
        <div id="liveScroll" class="scr"></div>
      </div>
    </div>

    <div id="calcModal" class="modal">
      <div class="inner">
        <div class="topbar">
          <div><b>고급계산</b> <small style="color:#555">— 자동채움 후 즉시 계산됩니다</small></div>
          <button id="btnCloseCalc" class="btn">닫기</button>
        </div>
        <div class="scr" style="padding:10px;">
          <div class="calc-grid">
            <div class="calc-pane calc-sid">
              <div class="head">계산기 목록</div>
              <div class="body">
                <div id="calcList" class="calc-list"></div>
              </div>
            </div>
            <div class="calc-pane">
              <div class="head">추가 Lab 붙여넣기</div>
              <div class="body">
                <div class="tabbar">
                  <button class="tab active" data-tab="serum">Serum</button>
                  <button class="tab" data-tab="abga">ABGA</button>
                  <button class="tab" data-tab="urine">Urine</button>
                  <button class="tab" data-tab="fluid">Body fluid</button>
                </div>
                <div id="calcPasteWrap">
                  <textarea id="calcSerumText" class="mini-input"
                    placeholder="혈액(serum) 보고서를 붙여넣으세요 (예: Sodium, Potassium, Chloride, Urea Nitrogen, Creatinine, AST/ALT, ALP, GGT, Total/Direct Bilirubin, Total Protein/Albumin, PT(INR), CBC 등)"
                    style="min-height:180px;"></textarea>
                  <textarea id="calcAbgaText" class="mini-input"
                    placeholder="ABGA 보고서를 붙여넣으세요 (예: ABGA-PH, ABGA-PCO2, ABGA-HCO3 ...)"
                    style="display:none; min-height:180px;"></textarea>
                  <textarea id="calcUrineText" class="mini-input"
                    placeholder="Urine 보고서를 붙여넣으세요 (예: Sodium (Urine), Creatinine (Urine) ...)"
                    style="display:none; min-height:180px;"></textarea>
                  <textarea id="calcFluidText" class="mini-input"
                    placeholder="흉수/복수 보고서를 붙여넣으세요 (Routine chemistry(B/F Other) ... )"
                    style="display:none; min-height:180px;"></textarea>
                </div>
                <div class="calc-foot">
                  <small class="muted-sm">* 입력하면 자동으로 파싱되어 반영됩니다.</small>
                </div>
              </div>
            </div>
            <div class="calc-pane">
              <div class="head">수동 입력/자동채움</div>
              <div class="body" id="calcInputsContainer"></div>
            </div>
            <div class="calc-pane">
              <div class="head">결과</div>
              <div class="body">
                <div id="calcResult" class="calc-out"></div>
              </div>
              <div class="calc-foot">
                <button id="btnCopyCalc" class="btn">결과 복사</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- 오프라인 라이브러리 (HTML 옆 vendor/) -->
  <script src="vendor/xlsx.full.min.js"></script>
  <script src="vendor/mammoth.browser.min.js"></script>
  <script src="vendor/FileSaver.min.js"></script>
  <script src="vendor/docx.js"></script>

  <!-- docx UMD/ESM 보정 -->
  <script type="module">
    async function ensureDocxLoaded() {
      if (window.docx && Object.keys(window.docx).length) return;
      async function tryImport(url) { try { const m = await import(url); if (m && Object.keys(m).length) { window.docx = m; return true; } } catch (_) { } return false; }
      async function tryBlob(path) { try { const r = await fetch(path); if (!r.ok) throw 0; const code = await r.text(); const blob = new Blob([code], { type: 'text/javascript' }); const u = URL.createObjectURL(blob); const ok = await tryImport(u); URL.revokeObjectURL(u); return ok; } catch (_) { return false; } }
      if (await tryImport('./vendor/docx.js')) return;
      if (await tryImport('./vendor/docx.umd.js')) return;
      if (await tryBlob('./vendor/docx.js')) return;
      if (await tryBlob('./vendor/docx.umd.js')) return;
      const s = document.getElementById('status'); if (s) { s.className = 'status err'; s.textContent = '❌ docx 로드 실패: vendor/docx.js 확인'; }
    }
    await ensureDocxLoaded();
  </script>

  <script>
    /* ===== 공통 ===== */
    function _setHeaderOffsetVar() { try { const h = document.querySelector('header')?.offsetHeight || 0; document.documentElement.style.setProperty('--header-h', h + 'px'); } catch (e) { } }
    window.addEventListener('load', _setHeaderOffsetVar);
    window.addEventListener('resize', _setHeaderOffsetVar);

    function setStatus(msg, type = "ok") { const el = document.getElementById("status"); if (!el) return; el.className = "status " + (type === "err" ? "err" : "ok"); el.textContent = msg; }
    window.addEventListener("load", () => {
      const missing = [];
      if (!window.XLSX) missing.push("XLSX");
      if (!window.mammoth) missing.push("mammoth");
      if (!window.docx) missing.push("docx");
      if (typeof window.saveAs !== "function") missing.push("FileSaver");
      if (missing.length) setStatus("필수 라이브러리 로드 실패 → " + missing.join(", ") + " — vendor 폴더 확인", "err");
      else setStatus("준비 완료. 엑셀 또는 DOCX를 선택하거나 드래그해 올리세요.", "ok");
    });

    /* ===== 드래그&드롭: 페이지 어디나 (텍스트영역에 파일경로 안찍히게 capture로 선처리) ===== */
    function handleDropFile(f) {
      if (!f) return;
      if (/\.(xlsx|xls|xlsm|xlsb)$/i.test(f.name)) loadExcel(f).then(() => { setStatus(`엑셀 로드 완료(드롭): ${f.name}`, "ok"); renderPatientList(); }).catch(err => setStatus("엑셀 읽기 실패: " + (err?.message || err), "err"));
      else if (/\.docx$/i.test(f.name)) parsePreviousDocx(f).then(() => { setStatus(`DOCX 로드 완료(드롭): ${f.name}`, "ok"); renderPatientList(); }).catch(err => setStatus("DOCX 읽기 실패: " + (err?.message || err), "err"));
      else setStatus("지원 형식: xlsx/xls/xlsm/xlsb/docx", "err");
    }
    document.addEventListener("dragover", e => { e.preventDefault(); }, { capture: true });
    document.addEventListener("drop", e => {
      e.preventDefault();
      const f = e.dataTransfer?.files?.[0];
      if (f) handleDropFile(f);
    }, { capture: true });

    /* ===== 상태 ===== */
    const STATE = {
      excelRows: [], professors: [], patients: new Map(),
      prevDocPatients: new Map(), selectedRegno: null,
      undo: new Map(), saveDirHandle: null
    };
    const TEMPLATE_ORDER = ["CBC :", "ANC :", "CRP :", "BUN/Cr :", "Na/K/Cl :", "TB/DB:", "AST/ALT:", "gGT/ALP :", "PT(INR) :", "TP/Alb :"];
    const NOTE_TEXT = "랩 결과 추후 확인하기";

    // 템플릿 라벨 매칭(대소문자/공백/콜론/표기변형 허용) → 표준 라벨 반환
    function matchTemplateLabel(line) {
      const s = (line || "").replace(/\s+/g, " ").trim();
      // 우선: 표준 라벨 정확 매칭
      for (const lbl of TEMPLATE_ORDER) { if (s.startsWith(lbl)) return lbl; }
      // 변형/별칭 허용 매칭
      if (/^(?:γ-?\s?GTP\s*\(?(?:GGT)?\)?|GGT|gGT)\s*\/\s*ALP\s*:/.test(s)) return "gGT/ALP :";
      if (/^AST\s*\(GOT\)\s*\/\s*ALT\s*\(GPT\)\s*:/.test(s) || /^AST\s*\/\s*ALT\s*:/.test(s)) return "AST/ALT:";
      if (/^TB\s*\/\s*DB\s*:/.test(s)) return "TB/DB:";
      if (/^PT\s*\(INR\)\s*:/.test(s)) return "PT(INR) :";
      if (/^TP\s*\/\s*Alb\s*:/.test(s)) return "TP/Alb :";
      if (/^BUN\s*\/\s*Cr\s*:/.test(s)) return "BUN/Cr :";
      if (/^Na\s*\/\s*K\s*\/\s*Cl\s*:/.test(s)) return "Na/K/Cl :";
      if (/^CBC\s*:/.test(s)) return "CBC :";
      if (/^ANC\s*:/.test(s)) return "ANC :";
      if (/^CRP\s*:/.test(s)) return "CRP :";
      return null;
    }

    /* ===== 유틸 ===== */
    const cleanNum = s => (s || "").toString().replaceAll(",", " ").trim();
    const keepIneqNum = s => { if (!s) return ""; const m = s.match(/([<>]=?\s*)?-?\d+(?:,\d{3})*(?:\.\d+)?/); return m ? m[0].replaceAll(",", "").replace(/\s+/g, "") : ""; };
    function numAfter(labelRe, s) { if (!s) return ""; const m = s.match(labelRe); if (!m) return ""; const rest = s.slice((m.index || 0) + m[0].length); return keepIneqNum(rest); }
    function roomSortKey(roomRaw) {
      const r = (roomRaw || "").toString().trim(); if (!r) return ["Z", 0, 0];
      if (/^\d{3}$/.test(r) && r.startsWith("2")) return ["C1", parseInt(r, 10), 0];
      if (/^\d{3}$/.test(r) && r.startsWith("4")) return ["C2", parseInt(r, 10), 0];
      if (/^3\d{3}$/.test(r)) { const floor = parseInt(r[1], 10); const room2 = parseInt(r.slice(-2), 10); return ["B", floor, room2]; }
      const digits = r.replace(/\D/g, ""); if (digits.length >= 3) {
        const floor = parseInt(digits.slice(0, digits.length - 2), 10); const room2 = parseInt(digits.slice(-2), 10);
        return ["A", -floor, room2]; // 15층→7층
      }
      return ["Z", 0, 0];
    }
    function expandWBC(raw) {
      const s = keepIneqNum(raw); if (!s) return "";
      const sign = (s.match(/^([<>]=?)/) || [, ""])[1]; const numStr = s.replace(/[<>]=?/g, ""); const n = Number(numStr);
      if (!isFinite(n)) return "";
      const out = Math.trunc(n * 1000); return sign ? (sign + out) : String(out);
    }

    /* ===== 기존 DOCX의 lab 블록 파싱 (Alb 이후 tail, NOTE 분리) ===== */
    function extractExistingMap(labText) {
      const map = {}; for (const lbl of TEMPLATE_ORDER) map[lbl] = "";
      const lines = (labText || "").split(/\r?\n/);
      for (const rawLine of lines) {
        const line = (rawLine || "").trim(); if (!line) continue;
        const key = matchTemplateLabel(line);
        if (!key) continue;
        // 콜론(:) 이후를 값으로 취함 (공백/화살표 누적 포함)
        const val = line.replace(/^[^:]+:\s*/, "").trim();
        if (val) map[key] = val;
      }
      return map;
    }
    function parseExistingBlock(raw) {
      const ORIG = raw || ""; const hadNote = ORIG.indexOf(NOTE_TEXT) !== -1;
      const textNoNote = ORIG.split(NOTE_TEXT).join("");
      const map = {}; for (const lbl of TEMPLATE_ORDER) map[lbl] = "";

      // Escape special regex characters for labels
      const escapedLabels = TEMPLATE_ORDER.map(l => l.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      // Create regex to match any label. Use capturing group to keep the delimiter in split result.
      const labelRe = new RegExp(`(${escapedLabels.join("|")})`, "i");

      // Split by labels. Result will be [pre-text, label1, val1, label2, val2, ...]
      const tokens = textNoNote.split(labelRe);

      let currentLabel = null;
      const tail = [];

      for (const token of tokens) {
        if (!token) continue;
        const trimmed = token.trim();

        // Check if this token is one of our labels
        // We use find because the split might leave some whitespace or case differences if not careful, 
        // but since we split by the regex derived from TEMPLATE_ORDER, exact match (ignoring case) should work.
        // However, the regex was case-insensitive ("i"), so we need to match back to the canonical label key.
        const matchedLabelKey = TEMPLATE_ORDER.find(l => l.toLowerCase() === trimmed.toLowerCase());

        if (matchedLabelKey) {
          currentLabel = matchedLabelKey;
        } else {
          // This is a value or pre-text
          if (currentLabel) {
            // It's a value for the current label
            // If map[currentLabel] already has content (unlikely with this split logic unless duplicate labels), append? 
            // Standard logic: just assign.
            map[currentLabel] = trimmed;
          } else {
            // Text before any label -> tail
            if (trimmed) tail.push(trimmed);
          }
        }
      }

      const anyFilled = Object.values(map).some(v => v && v.length);
      // If completely empty structure (unlikely if we just parsed labels), try repair? 
      // Actually, if we found labels, anyFilled might be false (all empty values), but that's valid.
      // The original logic checked if *values* were filled. 
      // If the user provided "CBC : ANC :", map has keys but empty values. anyFilled is false.
      // The original logic ran extractExistingMap in that case. Let's keep that fallback if needed, 
      // but our new logic is robust enough to handle the "empty values" case correctly (as empty strings).
      // So we might not need the fallback if we successfully matched labels.

      // Let's trust our split. If we found at least one label token, we are good.
      // If tokens.length <= 1 (no labels found), then maybe fallback.
      if (tokens.length <= 1) {
        const repaired = extractExistingMap(textNoNote.replace(/\s+/g, " ").trim());
        Object.assign(map, repaired || {});
      }

      return { map, tail: tail.join("\n").trim(), remind: hadNote };
    }

    /* ===== 신규 Lab 파서 ===== */
    function parseGeneralLab(text) {
      const t = text || "";
      const lines = t.split(/\r?\n/);
      const out = { "CBC :": "", "ANC :": "", "CRP :": "", "BUN/Cr :": "", "Na/K/Cl :": "", "TB/DB:": "", "AST/ALT:": "", "gGT/ALP :": "", "PT(INR) :": "", "TP/Alb :": "" };

      // ===== 1) CBC contiguous 패턴 탐색 (헤더 불요) =====
      let found = false;
      let idxW = -1, idxR = -1, idxHb = -1, idxHct = -1, idxMean = -1, idxMCV = -1, idxMCH = -1, idxMCHC = -1, idxRDW = -1, idxPlt = -1;

      const norm = (s) => (s || "").replace(/\s+/g, ' ').trim();

      for (let i = 0; i < lines.length; i++) {
        const s0 = norm(lines[i]);
        if (!/^WBC\b(?!\s*Diff)/i.test(s0)) continue;              // 정확히 WBC (Diff 제외)

        const s1 = norm(lines[i + 1]);
        const s2 = norm(lines[i + 2]);
        const s3 = norm(lines[i + 3]);
        if (!/^RBC\b/i.test(s1)) continue;
        if (!/^Hemoglobin\s*\(Hb\)/i.test(s2)) continue;
        if (!/^Hematocrit\s*\(Hct\)/i.test(s3)) continue;

        let k = i + 4;
        let meanPresent = false;
        const s4 = norm(lines[k]);
        if (/^Mean\s+Corp\s+Index\b/i.test(s4)) {
          // Mean 그룹이 시작되면, 하위 3줄(MCV/MCH/MCHC)이 반드시 연속으로 존재해야 함
          const s5 = norm(lines[k + 1]);
          const s6 = norm(lines[k + 2]);
          const s7 = norm(lines[k + 3]);
          if (!/^‥MCV\b/i.test(s5) || !/^‥MCH\b(?!C)/i.test(s6) || !/^‥MCHC\b/i.test(s7)) continue;
          meanPresent = true;
          idxMean = k; idxMCV = k + 1; idxMCH = k + 2; idxMCHC = k + 3;
          k += 4;
        }

        const sK = norm(lines[k]);
        const sK1 = norm(lines[k + 1]);
        if (!/^RDW\b/i.test(sK)) continue;
        if (!/^\s*Platelet\b/i.test(sK1)) continue;

        // contiguous CBC block 확정
        idxW = i; idxR = i + 1; idxHb = i + 2; idxHct = i + 3; idxRDW = k; idxPlt = k + 1;
        found = true;
        break;
      }

      // ===== 2) CBC 값 추출 (찾은 경우에만) =====
      let WBC_raw = null, RBC = null, Hb = null, Hct = null, MCV = null, MCH = null, MCHC = null, RDW = null, Plt = null;
      if (found) {
        const get = (idx) => norm(lines[idx]);
        WBC_raw = numAfter(/^WBC\b(?!\s*Diff)/i, get(idxW));
        RBC = numAfter(/^RBC\b/i, get(idxR));
        Hb = numAfter(/^Hemoglobin\s*\(Hb\)/i, get(idxHb));
        Hct = numAfter(/^Hematocrit\s*\(Hct\)/i, get(idxHct));
        if (idxMCV >= 0) MCV = numAfter(/^‥MCV\b/i, get(idxMCV));
        if (idxMCH >= 0) MCH = numAfter(/^‥MCH\b(?!C)/i, get(idxMCH));
        if (idxMCHC >= 0) MCHC = numAfter(/^‥MCHC\b/i, get(idxMCHC));
        RDW = numAfter(/^RDW\b/i, get(idxRDW));
        Plt = numAfter(/^\s*Platelet\b/i, get(idxPlt));

        const WBC_ul = WBC_raw ? expandWBC(WBC_raw) : "";
        out["CBC :"] = `${WBC_ul}/${Hb || ""}/${Plt || ""}`;
      }

      // ===== 3) 기타 패널 — 문서 전체에서 기존 규칙으로 수집 =====
      let ANC = null, CRP = null, BUN = null, Cr = null, Na = null, K = null, Cl = null, AST = null, ALT = null, GGT = null, ALP = null, INR = null, Alb = null, TBil = null, DBil = null, TP = null;

      for (let idx = 0; idx < lines.length; idx++) {
        const s = norm(lines[idx]);
        // Skip any lines that look like ABGA or Blood Gas to avoid confusion
        if (/\bABGA\b/i.test(s) || /\bBlood Gas\b/i.test(s)) continue;

        if (/(\bANC\b|Absolute neutrophil count)/i.test(s)) { const v = numAfter(/(\bANC\b|Absolute neutrophil count)/i, s); if (v) ANC = v; continue; }
        if (/^(CRP)\b|C-?reactive protein/i.test(s)) { const v = numAfter(/(CRP)\b|C-?reactive protein/i, s); if (v) CRP = v; continue; }
        if (/Urea Nitrogen\b/i.test(s)) { const v = numAfter(/Urea Nitrogen\b/i, s); if (v) BUN = v; continue; }
        if (/(\bCreatinine\b|\bCr\b)/i.test(s)) { const v = numAfter(/(\bCreatinine\b|\bCr\b)/i, s); if (v) Cr = v; continue; }
        if (/\bSodium\b/i.test(s)) { const v = numAfter(/\bSodium\b/i, s); if (v) Na = v; continue; }
        if (/\bPotassium\b/i.test(s)) { const v = numAfter(/\bPotassium\b/i, s); if (v) K = v; continue; }
        if (/\bChloride\b/i.test(s)) { const v = numAfter(/\bChloride\b/i, s); if (v) Cl = v; continue; }
        if (/AST\s*\(GOT\)/i.test(s)) { const v = numAfter(/AST\s*\(GOT\)/i, s); if (v) AST = v; continue; }
        if (/ALT\s*\(GPT\)/i.test(s)) { const v = numAfter(/ALT\s*\(GPT\)/i, s); if (v) ALT = v; continue; }
        if (/(γ-?GTP|GGT)/i.test(s)) { const v = numAfter(/(γ-?GTP|GGT)/i, s); if (v) GGT = v; continue; }
        if (/(\bALP\b|\(Alkaline Phosphatase\))/i.test(s)) { const v = numAfter(/(\bALP\b|\(Alkaline Phosphatase\))/i, s); if (v) ALP = v; continue; }
        if (/PT\s*\(INR\)/i.test(s)) { const v = numAfter(/PT\s*\(INR\)/i, s); if (v) INR = v; continue; }
        if (/(\bAlbumin\b|\bAlb\b)/i.test(s)) { const v = numAfter(/(\bAlbumin\b|\bAlb\b)/i, s); if (v) Alb = v; continue; }
        if (/^Total\s+Bilirubin\b/i.test(s)) { const v = numAfter(/^Total\s+Bilirubin\b/i, s); if (v && TBil === null) TBil = v; continue; }
        if (/^Direct\s+Bilirubin\b/i.test(s)) { const v = numAfter(/^Direct\s+Bilirubin\b/i, s); if (v && DBil === null) DBil = v; continue; }
        if (/^Total\s+Protein\b/i.test(s)) { const v = numAfter(/^Total\s+Protein\b/i, s); if (v && TP === null) TP = v; continue; }
      }
      if (ANC) out["ANC :"] = ANC;
      if (CRP) out["CRP :"] = CRP;
      if (BUN || Cr) out["BUN/Cr :"] = [BUN || "", Cr || ""].join("/");
      if (Na || K || Cl) out["Na/K/Cl :"] = [Na || "", K || "", Cl || ""].join("/");
      if (TBil || DBil) out["TB/DB:"] = [TBil || "", DBil || ""].join("/");
      if (AST || ALT) out["AST/ALT:"] = [AST || "", ALT || ""].join("/");
      if (GGT || ALP) out["gGT/ALP :"] = [GGT || "", ALP || ""].join("/");
      if (INR) out["PT(INR) :"] = INR;
      if (TP || Alb) out["TP/Alb :"] = [TP || "", Alb || ""].join("/");

      // ===== 4) _CBC_DETAILS 메타 저장 =====
      const detail = {};
      if (WBC_raw !== null) { detail.WBC_10e9_perL = keepIneqNum(WBC_raw); const w = expandWBC(WBC_raw); if (w) detail.WBC_per_uL = w; }
      if (RBC !== null) detail.RBC_10e12_perL = keepIneqNum(RBC);
      if (Hb !== null) detail.Hb_g_dl = keepIneqNum(Hb);
      if (Hct !== null) detail.Hct_pct = keepIneqNum(Hct);
      if (MCV !== null) detail.MCV_fL = keepIneqNum(MCV);
      if (MCH !== null) detail.MCH_pg = keepIneqNum(MCH);
      if (MCHC !== null) detail.MCHC_g_dl = keepIneqNum(MCHC);
      if (RDW !== null) detail.RDW_pct = keepIneqNum(RDW);
      if (Plt !== null) {
        detail.Plt_10e9_perL = keepIneqNum(Plt);
        const pnum = Number(keepIneqNum(Plt).replace(/[<>]=?/g, ""));
        if (isFinite(pnum)) detail.Plt_per_uL = String(Math.trunc(pnum * 1000));
      }
      detail._order_ok = !!found;
      out["_CBC_DETAILS"] = detail;

      return out;
    }

    function parseABGALab(text) {
      const t = text || "";
      const lines = t.split(/\r?\n/);
      const norm = (s) => (s || "").replace(/\s+/g, ' ').trim();
      const numAfter = (labelRe, s) => { if (!s) return ""; const m = s.match(labelRe); if (!m) return ""; const rest = s.slice((m.index || 0) + m[0].length); return keepIneqNum(rest); };

      let abga_ph = null, abga_pco2 = null, abga_po2 = null, abga_hco3 = null, abga_be = null, abga_sao2 = null, abga_lactate = null;

      for (let idx = 0; idx < lines.length; idx++) {
        const s = norm(lines[idx]);
        if (/ABGA-PH/i.test(s)) { const v = numAfter(/ABGA-PH/i, s); if (v) abga_ph = v; continue; }
        if (/ABGA-PCO2/i.test(s)) { const v = numAfter(/ABGA-PCO2/i, s); if (v) abga_pco2 = v; continue; }
        if (/ABGA-PO2/i.test(s)) { const v = numAfter(/ABGA-PO2/i, s); if (v) abga_po2 = v; continue; }
        if (/ABGA-HCO3/i.test(s)) { const v = numAfter(/ABGA-HCO3/i, s); if (v) abga_hco3 = v; continue; }
        if (/(ABGA-)?Base\s*Excess/i.test(s)) { const v = numAfter(/(ABGA-)?Base\s*Excess/i, s); if (v) abga_be = v; continue; }
        if (/(ABGA-)?(SaO2|O2\s*SAT)/i.test(s)) { const v = numAfter(/(ABGA-)?(SaO2|O2\s*SAT)/i, s); if (v) abga_sao2 = v; continue; }
        if (/Lactic Acid/i.test(s)) { const v = numAfter(/Lactic Acid/i, s); if (v) abga_lactate = v; continue; }
      }

      const abgaParts = [];
      const values = {};
      if (abga_ph) { abgaParts.push(`${abga_ph}`); values.pH = parseFloat(abga_ph); }
      if (abga_pco2) { abgaParts.push(`${abga_pco2}`); values.pCO2 = parseFloat(abga_pco2); }
      if (abga_po2) { abgaParts.push(`${abga_po2}`); values.pO2 = parseFloat(abga_po2); }
      if (abga_hco3) { abgaParts.push(`${abga_hco3}`); values.HCO3 = parseFloat(abga_hco3); }
      if (abga_be) { abgaParts.push(`${abga_be}`); values.BE = parseFloat(abga_be); }
      if (abga_sao2) { abgaParts.push(`${abga_sao2}%`); values.SaO2 = parseFloat(abga_sao2); }
      if (abga_lactate) { abgaParts.push(`Lac ${abga_lactate}`); values.Lactate = parseFloat(abga_lactate); }

      return {
        values: values,
        str: abgaParts.length > 0 ? abgaParts.join(" / ") : ""
      };
    }

    /* ===== mammoth 텍스트 추출 보조 ===== */
    function tdToMultiline(td) {
      if (!td) return "";
      const ps = td.querySelectorAll("p");
      if (ps && ps.length) {
        return Array.from(ps).map(p => (p.textContent || "").replace(/\s+\n/g, "\n").trim()).join("\n").replace(/\n{3,}/g, "\n\n").trim();
      }
      return (td.innerText || td.textContent || "").replace(/\r?\n/g, "\n").trim();
    }

    /* ===== DOCX(직전) 파싱 → prevDocPatients ===== */
    async function parsePreviousDocx(file) {
      if (!file) return;
      const arrayBuffer = await file.arrayBuffer();
      const { value: html } = await window.mammoth.convertToHtml({ arrayBuffer });
      const container = document.createElement("div"); container.innerHTML = html;

      const tables = Array.from(container.querySelectorAll("table"));
      if (tables.length) {
        STATE.prevDocPatients.clear();
        let currProfessor = null;
        for (const table of tables) {
          const rows = Array.from(table.rows);
          for (let i = 0; i < rows.length; i++) {
            const cells = Array.from(rows[i].cells);
            const text0 = (cells[0]?.innerText || "").trim();

            // Professor check
            if (cells.length === 1 && /^\[교수\]/.test(text0)) {
              currProfessor = text0.replace(/^\[교수\]\s*/, "").trim();
              continue;
            }

            // Patient Row Detection (Hybrid: Structure + Text)
            if (cells.length >= 5) {
              let headText = "";
              let diagText = "";

              // 1. Try Nested Table in Col 1
              const c1Table = cells[0].querySelector("table");
              if (c1Table) {
                const c1Rows = Array.from(c1Table.querySelectorAll("tr"));
                if (c1Rows.length >= 1) headText = c1Rows[0].innerText.trim();
                if (c1Rows.length >= 2) diagText = tdToMultiline(c1Rows[1].querySelector("td"));
              } else {
                // 2. Fallback: Text based (assuming header is just the text)
                headText = cells[0].innerText.trim();
              }

              // Relaxed Regex: Search for pattern anywhere
              const headerRe = /(\d{3,4})\s+(\S+)\s+([MF]\/\d{1,3})\s+(\d{6,})/;
              const m = headText.match(headerRe);

              if (m) {
                const [, room, name, sa, regno] = m;

                // If we used fallback for Col 1 (no nested table),
                // the text AFTER the header match is likely the Diagnosis.
                if (!c1Table && !diagText) {
                  const matchIndex = m.index + m[0].length;
                  diagText = headText.substring(matchIndex).trim();
                }

                // Col 2: Oxy (Top) / VS (Bottom)
                let oxyDetail = "";
                let vs = "";
                const c2Table = cells[1].querySelector("table");
                if (c2Table) {
                  const c2Rows = Array.from(c2Table.querySelectorAll("tr"));
                  // Strict Row Logic: 2 rows -> Oxy/VS, 1 row -> VS
                  if (c2Rows.length >= 2) {
                    oxyDetail = tdToMultiline(c2Rows[0].querySelector("td"));
                    vs = tdToMultiline(c2Rows[1].querySelector("td"));
                  } else if (c2Rows.length === 1) {
                    vs = tdToMultiline(c2Rows[0].querySelector("td"));
                  }
                } else {
                  // Fallback: Check first line for Oxy keywords
                  const fullText = tdToMultiline(cells[1]);
                  const lines = fullText.split('\n');
                  if (lines.length > 0 && /^(RA|Nasal|RM|HFNC|Vent|T-piece|Trach)/i.test(lines[0])) {
                    oxyDetail = lines[0].trim();
                    vs = lines.slice(1).join('\n').trim();
                  } else {
                    vs = fullText;
                  }
                }

                // Col 3: ABGA (Top) / Lab (Bottom)
                let abga = "";
                let labText = "";
                const c3Table = cells[2].querySelector("table");
                if (c3Table) {
                  const c3Rows = Array.from(c3Table.querySelectorAll("tr"));
                  // Strict Row Logic: 2 rows -> ABGA/Lab, 1 row -> Lab
                  if (c3Rows.length >= 2) {
                    abga = tdToMultiline(c3Rows[0].querySelector("td"));
                    labText = tdToMultiline(c3Rows[1].querySelector("td"));
                  } else if (c3Rows.length === 1) {
                    labText = tdToMultiline(c3Rows[0].querySelector("td"));
                  }
                } else {
                  // Fallback: Check first line for ABGA keywords
                  const fullText = tdToMultiline(cells[2]);
                  const lines = fullText.split('\n');
                  if (lines.length > 0 && /(ABGA|pH|pCO2|pO2|HCO3)/i.test(lines[0])) {
                    abga = lines[0].trim();
                    labText = lines.slice(1).join('\n').trim();
                  } else {
                    labText = fullText;
                  }
                }

                // Col 4: C4
                const c4 = tdToMultiline(cells[3]);

                // Col 5: IO (Top) / C5 (Bottom)
                let io = "";
                let c5 = "";
                const c5Table = cells[4].querySelector("table");
                if (c5Table) {
                  const c5Rows = Array.from(c5Table.querySelectorAll("tr"));
                  // Strict Row Logic: 2 rows -> IO/C5, 1 row -> C5
                  if (c5Rows.length >= 2) {
                    io = tdToMultiline(c5Rows[0].querySelector("td")).replace(/^I\/O Target\s*:\s*/i, "");
                    c5 = tdToMultiline(c5Rows[1].querySelector("td"));
                  } else if (c5Rows.length === 1) {
                    c5 = tdToMultiline(c5Rows[0].querySelector("td"));
                  }
                } else {
                  // Fallback: Check first line for I/O Target
                  const fullText = tdToMultiline(cells[4]);
                  const lines = fullText.split('\n');
                  if (lines.length > 0 && /^I\/O Target\s*:/i.test(lines[0])) {
                    io = lines[0].replace(/^I\/O Target\s*:\s*/i, "").trim();
                    c5 = lines.slice(1).join('\n').trim();
                  } else {
                    c5 = fullText;
                  }
                }

                const parsedBlock = parseExistingBlock(labText);
                const existing = parsedBlock.map;
                const existingTail = parsedBlock.tail;
                const remind = !!parsedBlock.remind;

                // Parse OxyDetail
                let oxyMode = "RA";
                let oxyData = {};
                if (oxyDetail) {
                  if (oxyDetail.startsWith("RA")) oxyMode = "RA";
                  else if (oxyDetail.startsWith("Nasal")) { oxyMode = "Nasal"; const lMatch = oxyDetail.match(/Nasal (\d+(\.\d+)?)L/); if (lMatch) oxyData.nasal_l = parseFloat(lMatch[1]); }
                  else if (oxyDetail.startsWith("RM")) { oxyMode = "RM"; const lMatch = oxyDetail.match(/RM (\d+(\.\d+)?)L/); if (lMatch) oxyData.rm_l = parseFloat(lMatch[1]); }
                  else if (oxyDetail.startsWith("HFNC")) {
                    oxyMode = "HFNC";
                    const parts = oxyDetail.match(/HFNC (\d+)\/(\d+(\.\d+)?)/);
                    if (parts) {
                      oxyData.hfnc_flow = parseFloat(parts[1]);
                      let f = parseFloat(parts[2]);
                      if (f <= 1.0) f = Math.round(f * 100);
                      oxyData.hfnc_fio2 = f;
                    }
                  }
                  else if (oxyDetail.startsWith("Vent")) {
                    oxyMode = "Vent";
                    const modeMatch = oxyDetail.match(/^(AC-VC|AC-PC|SIMV-VC|SIMV-PC|PSV|CPAP|BiPAP)/);
                    if (modeMatch) oxyData.vent_mode = modeMatch[1];
                    const fio2Match = oxyDetail.match(/FiO₂ (\d+(\.\d+)?)/); if (fio2Match) oxyData.v_fio2 = parseFloat(fio2Match[1]);
                    const rrMatch = oxyDetail.match(/RR (\d+)/); if (rrMatch) oxyData.v_rr = parseFloat(rrMatch[1]);
                    const vtMatch = oxyDetail.match(/VT (\d+)/); if (vtMatch) oxyData.v_vt = parseFloat(vtMatch[1]);
                    const peepMatch = oxyDetail.match(/PEEP (\d+)/); if (peepMatch) oxyData.v_peep = parseFloat(peepMatch[1]);
                    const psMatch = oxyDetail.match(/PS (\d+)/); if (psMatch) oxyData.v_ps = parseFloat(psMatch[1]);
                    const pinspMatch = oxyDetail.match(/Pinsp (\d+)/); if (pinspMatch) oxyData.v_pinsp = parseFloat(pinspMatch[1]);
                    const ieMatch = oxyDetail.match(/I:E 1:(\d+(\.\d+)?)/); if (ieMatch) oxyData.v_ie = parseFloat(ieMatch[1]);
                    const ipapMatch = oxyDetail.match(/IPAP (\d+)/); if (ipapMatch) oxyData.v_ipap = parseFloat(ipapMatch[1]);
                    const epapMatch = oxyDetail.match(/EPAP (\d+)/); if (epapMatch) oxyData.v_epap = parseFloat(epapMatch[1]);
                  }
                  else if (oxyDetail.startsWith("T-piece")) { oxyMode = "T-piece"; oxyData.other_detail = oxyDetail.substring("T-piece".length).trim(); }
                  else if (oxyDetail.startsWith("Trach")) { oxyMode = "Trach"; oxyData.other_detail = oxyDetail.substring("Trach".length).trim(); }
                  else { oxyMode = "Other"; oxyData.other_detail = oxyDetail; }
                }

                STATE.prevDocPatients.set(regno, { regno, name, sa, room, professor: currProfessor, existing, existingTail, extras: { diag: diagText, vs, c4, c5, io, abga, oxyMode, oxyData, oxyDetail }, remind });
              }
            }
          }
        }
        if (STATE.prevDocPatients.size) return;
      }

      // Fallback: 텍스트 라인 기반
      const text = container.innerText.replace(/\u00A0/g, " ").split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const headerRe = /^(\d{3,4})\s+(\S+)\s+([MF]\/\d{1,3})\s+(\d{6,})$/;
      STATE.prevDocPatients.clear(); let currProfessor = null; let i = 0;
      while (i < text.length) {
        const line = text[i];
        if (/\[교수\]/.test(line)) { currProfessor = line.replace(/\[교수\]\s*/, '').trim(); i++; continue; }
        const m = line.match(headerRe);
        if (m) {
          const [_, room, name, sa, regno] = m;
          const existing = {}; const extras = { diag: "", vs: "", c4: "", c5: "", abga: "", io: "", oxyMode: "RA", oxyData: {}, oxyDetail: "" };
          let peek = i + 1, collected = 0;
          while (peek < text.length && collected < 50) {
            const L = text[peek];
            const which = TEMPLATE_ORDER.find(lbl => L.startsWith(lbl));
            if (which) existing[which] = L.slice(which.length).trim();
            else if (/^#\s*/.test(L)) {
              const diagLines = []; while (peek < text.length && /^#\s*/.test(text[peek])) { diagLines.push(text[peek]); peek++; }
              extras.diag = diagLines.join("\n"); collected += diagLines.length; continue;
            } else if (/^V\/?S\b/i.test(L)) {
              const vsLines = [L.replace(/^V\/?S\s*:?\s*/i, "").trim()]; peek++;
              while (peek < text.length) {
                const NL = text[peek];
                if (!NL || headerRe.test(NL) || /\[교수\]/.test(NL) || TEMPLATE_ORDER.some(lbl => NL.startsWith(lbl)) || /^#\s*/.test(NL)) break;
                vsLines.push(NL); peek++;
              }
              extras.vs = vsLines.join("\n"); collected += vsLines.length; continue;
            } else if (/^I\/O Target\b/i.test(L)) {
              const ioLines = [L.replace(/^I\/O Target\s*:?\s*/i, "").trim()]; peek++;
              while (peek < text.length) {
                const NL = text[peek];
                if (!NL || headerRe.test(NL) || /\[교수\]/.test(NL) || TEMPLATE_ORDER.some(lbl => NL.startsWith(lbl)) || /^#\s*/.test(NL)) break;
                ioLines.push(NL); peek++;
              }
              extras.io = ioLines.join("\n"); collected += ioLines.length; continue;
            } else if (/^(RA|Nasal|RM|HFNC|Vent|T-piece|Trach)/i.test(L)) { // Attempt to parse old oxyDetail
              extras.oxyDetail = L;
              if (L.startsWith("RA")) extras.oxyMode = "RA";
              else if (L.startsWith("Nasal")) extras.oxyMode = "Nasal";
              else if (L.startsWith("RM")) extras.oxyMode = "RM";
              else if (L.startsWith("HFNC")) extras.oxyMode = "HFNC";
              else if (L.startsWith("Vent")) extras.oxyMode = "Vent";
              else if (L.startsWith("T-piece")) extras.oxyMode = "T-piece";
              else if (L.startsWith("Trach")) extras.oxyMode = "Trach";
              // No structured oxyData from plain text parsing, will be empty.
              peek++; collected++; continue;
            }
            else if (headerRe.test(L) || /\[교수\]/.test(L)) break;
            peek++; collected++;
          }
          const blobLine = Object.entries(existing).map(([k, v]) => (k + " " + v).trim()).join(" ");
          const repaired = extractExistingMap(blobLine); for (const k of TEMPLATE_ORDER) { if (repaired[k]) existing[k] = repaired[k]; }
          const hasNote = text.slice(i, peek).some(L => (L || "").trim() === NOTE_TEXT);
          STATE.prevDocPatients.set(regno, { regno, name, sa, room, professor: currProfessor, existing, extras, remind: hasNote, existingTail: "" });
          i = peek; continue;
        }
        i++;
      }
    }

    /* ===== 엑셀 로드 ===== */
    async function loadExcel(file) {
      const ab = await file.arrayBuffer();
      const wb = XLSX.read(ab, { type: 'array' });
      const sheetName = wb.SheetNames[0];
      const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { defval: "" });
      STATE.excelRows = rows;

      const cols = Object.keys(rows[0] || {}); const required = ["등록번호", "성명", "병실", "S/A", "주치의"];
      const missing = required.filter(k => !cols.includes(k));
      if (missing.length) setStatus("엑셀 열 이름 누락: " + missing.join(", "), "err");

      STATE.patients.clear(); const profSet = new Set();
      for (const r of rows) {
        const regno = (r["등록번호"] || "").toString().trim(); if (!regno) continue;
        const name = (r["성명"] || "").toString().trim();
        const room = (r["병실"] || "").toString().trim();
        const sa = (r["S/A"] || "").toString().trim();
        const prof = (r["주치의"] || "").toString().trim(); if (prof) profSet.add(prof);
        const prev = STATE.prevDocPatients.get(regno);
        STATE.patients.set(regno, {
          regno, name, room, sa, professor: prof,
          existing: prev?.existing || {},
          existingTail: prev?.existingTail || "",
          newRaw: "", parsed: {}, newRawABGA: "",
          extras: prev?.extras || { diag: "", vs: "", c4: "", c5: "", abga: "", io: "", oxyMode: "RA", oxyData: {}, oxyDetail: "" },
          bedNo: (r["Bed No"] || r["BedNo"] || "").toString().trim(),
          remind: typeof prev?.remind === "boolean" ? prev.remind : false,
          done: false
        });
      }
      STATE.professors = Array.from(profSet).sort();
    }

    /* ===== 리스트/트레이 렌더 ===== */
    function renderPatientList() {
      const root = document.getElementById("patientList");
      const tray = document.getElementById("dischargeTray");
      root.innerHTML = ""; tray.innerHTML = "";

      const excelRegnos = new Set(STATE.patients.keys());
      const prevRegnos = new Set(STATE.prevDocPatients.keys());

      const groups = new Map();
      for (const [regno, p] of STATE.patients) {
        if (prevRegnos.has(regno)) {
          const prev = STATE.prevDocPatients.get(regno);
          p.existing = prev?.existing || p.existing || {};
          const ex = p.extras || {}; const allEmpty = !ex || Object.values(ex).every(v => !v);
          if (allEmpty) p.extras = prev?.extras ? { ...prev.extras } : { diag: "", vs: "", c4: "", c5: "", io: "", oxyMode: "RA", oxyData: {}, oxyDetail: "" };
        }
        const key = p.professor || "[주치의 미지정]";
        if (!groups.has(key)) groups.set(key, []);
        const status = prevRegnos.has(regno) ? "existing" : "new";
        groups.get(key).push({ ...p, _status: status });
      }

      const sortedProf = Array.from(groups.keys()).sort();
      for (const prof of sortedProf) {
        const arr = groups.get(prof).slice().sort((a, b) => {
          const ka = roomSortKey(a.room), kb = roomSortKey(b.room);
          return (ka[0] < kb[0] ? -1 : ka[0] > kb[0] ? 1 : (ka[1] - kb[1]) || (ka[2] - kb[2]) || a.name.localeCompare(b.name, 'ko'));
        });
        const g = document.createElement("div"); g.className = "group";
        const h = document.createElement("div"); h.className = "ghead"; h.textContent = prof || "[주치의 미지정]";
        g.appendChild(h);
        for (const p of arr) g.appendChild(patientPill(p));
        root.appendChild(g);
      }

      for (const regno of prevRegnos) {
        if (!excelRegnos.has(regno)) {
          const prev = STATE.prevDocPatients.get(regno);
          tray.appendChild(patientPill({ regno, name: prev.name || "(이름)", room: prev.room || "", sa: prev.sa || "", professor: prev.professor || "[전과/퇴원]", _status: "discharged" }, true));
        }
      }
      document.getElementById("btnGenerate").disabled = STATE.patients.size === 0;
    }
    function patientPill(p, isDischarge = false) {
      const el = document.createElement("div");
      const cls = ["pill"]; if (p._status) cls.push(p._status); if (isDischarge || p._status === "discharged") cls.push("discharged"); if (p.done) cls.push("done");
      el.className = cls.join(" "); el.dataset.regno = p.regno;
      el.innerHTML = `
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div><b>${p.room || "-"}</b> ${p.name || ""} <span class="muted">${p.sa || ""}</span> <span class="muted">${p.regno}</span></div>
      <div class="right">
        <label style="font-size:11px;color:#555;"><input type="checkbox" class="doneChk" ${p.done ? 'checked' : ''}/> 완료</label>
      </div>
    </div>
    ${isDischarge ? `<div class="row"><span class="badge">퇴원/전과?</span>
      <select class="profMove"><option value="">교수 선택</option>${STATE.professors.map(x => `<option>${x}</option>`).join("")}</select>
      <button class="btn send">보내기</button>
      <button class="btn" style="border-color:#f55;color:#f55" onclick="this.closest('.pill').remove()">삭제</button>
    </div>` : ``}
  `;
      el.onclick = (e) => {
        if (e.target && (e.target.classList.contains("send") || e.target.classList.contains("profMove") || e.target.classList.contains("doneChk"))) return;
        document.querySelectorAll(".pill").forEach(n => n.classList.remove("active"));
        el.classList.add("active");
        STATE.selectedRegno = p.regno;
        showPatient(p.regno);
      };
      const chk = el.querySelector(".doneChk");
      if (chk) {
        chk.addEventListener("click", ev => ev.stopPropagation());
        chk.addEventListener("change", ev => {
          const checked = !!ev.target.checked; const pp = STATE.patients.get(p.regno); if (pp) pp.done = checked; el.classList.toggle("done", checked);
        });
      }
      if (isDischarge) {
        const sel = el.querySelector(".profMove");
        const defProf = p.professor || "";
        if (defProf) {
          if (![...sel.options].some(o => o.value === defProf)) { const opt = document.createElement("option"); opt.value = defProf; opt.textContent = defProf; sel.insertBefore(opt, sel.firstChild); }
          sel.value = defProf;
        }
        el.querySelector(".send")?.addEventListener("click", () => {
          const prof = sel?.value || ""; if (!prof) { alert("교수를 선택하세요"); return; }
          const prevFull = STATE.prevDocPatients.get(p.regno);
          STATE.patients.set(p.regno, {
            regno: p.regno, name: p.name, room: p.room, sa: p.sa, professor: prof || prevFull?.professor || p.professor || "",
            existing: prevFull?.existing || {}, existingTail: prevFull?.existingTail || "",
            newRaw: "", parsed: {}, newRawABGA: "", extras: prevFull?.extras || { diag: "", vs: "", c4: "", c5: "", io: "", oxyMode: "RA", oxyData: {}, oxyDetail: "" }, remind: typeof prevFull?.remind === "boolean" ? prevFull.remind : false, done: false
          });
          el.remove(); renderPatientList();
        });
      }
      return el;
    }

    /* ===== 우측 미리보기 텍스트 ===== */
    function refreshPreviewOnly(regno) {
      const p = STATE.patients.get(regno) || STATE.prevDocPatients.get(regno);
      const host = document.getElementById("resultLab"); if (!p || !host) return;
      const ex = p.existing || {}; const parsed = p.parsed || {};
      const merged = TEMPLATE_ORDER.map(lbl => {
        const base = ex[lbl] || ""; const nv = parsed[lbl] || "";
        if (!nv) return `${lbl} ${base}`;
        let toks = base ? base.split("→").map(s => s.trim()).filter(Boolean) : [];
        if (toks[toks.length - 1] !== nv) toks.push(nv);
        while (toks.length > 3) toks.shift();
        return `${lbl} ${toks.length ? toks.join("→") : nv}`;
      }).join("\n");
      const tail = p.existingTail ? ("\n" + p.existingTail) : "";
      const body = merged + tail;
      const labFull = p.remind ? (body + "\n\n" + NOTE_TEXT) : body;
      host.textContent = labFull;
    }

    /* ===== 선택 환자 표시/바인딩 ===== */
    /* Auto-grow Textarea (Scroll Jitter Fix) */
    function bindAutoGrow(el) {
      if (!el) return;
      // Prevent re-binding if already processed
      if (el.dataset.autogrow === '1') {
        // If already bound, just trigger a resize to update height
        const grow = () => {
          const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          el.style.height = 'auto';
          el.style.height = (el.scrollHeight) + 'px';
          window.scrollTo(0, scrollTop);
        };
        requestAnimationFrame(grow);
        return;
      }

      el.dataset.autogrow = '1';

      const resize = () => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        el.style.height = 'auto'; // Temporarily collapse to calculate true scrollHeight
        el.style.height = (el.scrollHeight) + 'px'; // Set to content height
        window.scrollTo(0, scrollTop); // Restore scroll position to prevent jitter
      };

      el.addEventListener('input', resize);
      el.addEventListener('change', resize); // Also resize on change (e.g., programmatic changes)

      // Initial resize (delay slightly to ensure render and correct scrollHeight calculation)
      setTimeout(resize, 0);
    }
    function showPatient(regno) {
      const p = STATE.patients.get(regno) || STATE.prevDocPatients.get(regno);
      const existingEl = document.getElementById("existingLabInput");
      const newElGeneral = document.getElementById("newLabGeneral");
      const newElABGA = document.getElementById("newLabABGA");

      const ex = p?.existing || {}; const exTail = (STATE.patients.get(regno)?.existingTail) || (STATE.prevDocPatients.get(regno)?.existingTail) || "";
      const existingText = TEMPLATE_ORDER.map(lbl => `${lbl} ${(ex[lbl] || "")}`).join("\n") + (exTail ? ("\n" + exTail) : "");
      existingEl.value = existingText;
      existingEl.oninput = () => {
        const txt = existingEl.value || ""; const blk = parseExistingBlock(txt); const pp = STATE.patients.get(regno);
        if (pp) { pp.existing = blk.map; pp.existingTail = blk.tail; refreshPreviewOnly(regno); }
      };
      bindAutoGrow(existingEl);

      newElGeneral.value = p?.newRaw || ""; bindAutoGrow(newElGeneral);
      newElABGA.value = p?.newRawABGA || ""; bindAutoGrow(newElABGA);

      // Load Oxy Data
      const extras = (STATE.patients.get(regno)?.extras) || { diag: "", vs: "", c4: "", c5: "", abga: "", io: "", oxyMode: "RA", oxyData: {}, oxyDetail: "" };
      const oxyData = extras.oxyData || {};
      currentOxyMode = extras.oxyMode || "RA";
      setOxyMode(currentOxyMode);

      // Populate inputs
      if (oxyData.nasal_l) document.getElementById('oxy_nasal_l').value = oxyData.nasal_l; else document.getElementById('oxy_nasal_l').value = '1';
      if (oxyData.rm_l) document.getElementById('oxy_rm_l').value = oxyData.rm_l; else document.getElementById('oxy_rm_l').value = '10';
      if (oxyData.hfnc_flow) document.getElementById('oxy_hfnc_flow').value = oxyData.hfnc_flow; else document.getElementById('oxy_hfnc_flow').value = '40';
      if (oxyData.hfnc_fio2) document.getElementById('oxy_hfnc_fio2').value = oxyData.hfnc_fio2; else document.getElementById('oxy_hfnc_fio2').value = '40';

      if (oxyData.vent_mode) document.getElementById('oxy_vent_mode').value = oxyData.vent_mode; else document.getElementById('oxy_vent_mode').value = 'AC-VC';
      if (oxyData.v_fio2) document.getElementById('v_fio2').value = oxyData.v_fio2; else document.getElementById('v_fio2').value = '';
      if (oxyData.v_rr) document.getElementById('v_rr').value = oxyData.v_rr; else document.getElementById('v_rr').value = '';
      if (oxyData.v_vt) document.getElementById('v_vt').value = oxyData.v_vt; else document.getElementById('v_vt').value = '';
      if (oxyData.v_peep) document.getElementById('v_peep').value = oxyData.v_peep; else document.getElementById('v_peep').value = '';
      if (oxyData.v_ps) document.getElementById('v_ps').value = oxyData.v_ps; else document.getElementById('v_ps').value = '';
      if (oxyData.v_pinsp) document.getElementById('v_pinsp').value = oxyData.v_pinsp; else document.getElementById('v_pinsp').value = '';
      if (oxyData.v_ie) document.getElementById('v_ie').value = oxyData.v_ie; else document.getElementById('v_ie').value = '';
      if (oxyData.v_ipap) document.getElementById('v_ipap').value = oxyData.v_ipap; else document.getElementById('v_ipap').value = '';
      if (oxyData.v_epap) document.getElementById('v_epap').value = oxyData.v_epap; else document.getElementById('v_epap').value = '';

      if (oxyData.other_detail) document.getElementById('oxy_other_detail').value = oxyData.other_detail; else document.getElementById('oxy_other_detail').value = '';

      updateVentFields(); // Ensure correct fields shown
      updateOxyString();  // Refresh preview

      const diagEl = document.getElementById("diagText");
      const vsEl = document.getElementById("vsText");
      const c4El = document.getElementById("c4Text");
      const c5El = document.getElementById("c5Text");
      const abgaEl = document.getElementById("abgaText");
      const ioEl = document.getElementById("ioText");

      diagEl.value = extras.diag || ""; vsEl.value = extras.vs || ""; c4El.value = extras.c4 || ""; c5El.value = extras.c5 || "";
      abgaEl.value = extras.abga || ""; ioEl.value = extras.io || "";

      const bind = (el, key) => el.oninput = () => { const pp = STATE.patients.get(regno); if (!pp) return; pp.extras = pp.extras || {}; pp.extras[key] = el.value; };
      bind(diagEl, "diag"); bind(vsEl, "vs"); bind(c4El, "c4"); bind(c5El, "c5");
      bind(abgaEl, "abga"); bind(ioEl, "io");

      [diagEl, vsEl, c4El, c5El, abgaEl, ioEl].forEach(bindAutoGrow);

      const selbar = document.getElementById("selbar");
      if (p) {
        const isNew = !STATE.prevDocPatients.has(regno);
        selbar.style.display = "flex";
        selbar.innerHTML = `<b>${p.room || '-'}</b> ${p.name || ''} <span class="muted">${p.sa || ''}</span> <span class="muted">${p.regno || ''}</span> <span class="tag">${isNew ? '신환' : '기존'}</span> <span class="tag">${p.professor || ''}</span>`;
      } else selbar.style.display = "none";

      refreshPreviewOnly(regno);

      const btnR = document.getElementById("btnRemind");
      if (btnR) { const flag = STATE.patients.get(regno)?.remind; btnR.textContent = flag ? "랩 확인 메모 취소" : "랩 확인 메모 추가"; }
      _setHeaderOffsetVar();
      attachProxyWheelToTextareas(document);
    }

    /* ===== 신규 Lab 자동 적용 & 되돌리기 ===== */
    let _labTimer = null;
    let _abgaTimer = null;

    function applyGeneralLab() {
      const regno = STATE.selectedRegno; if (!regno) { setStatus("환자를 먼저 선택하세요", "err"); return; }
      const raw = document.getElementById("newLabGeneral").value || "";
      const p = STATE.patients.get(regno); if (!p) { setStatus("선택된 환자를 찾을 수 없습니다.", "err"); return; }

      // Undo 저장 (General Lab만)
      STATE.undo.set(regno, {
        ...STATE.undo.get(regno), // Preserve existing undo state for ABGA if any
        newRaw: p.newRaw,
        parsed: { ...p.parsed } // Shallow copy of parsed to preserve ABGA fields
      });

      const parsedGeneral = parseGeneralLab(raw);
      p.newRaw = raw;
      // Merge general lab fields into p.parsed, preserving ABGA fields
      p.parsed = { ...p.parsed, ...parsedGeneral };

      showPatient(regno);
    }

    function applyABGALab() {
      const regno = STATE.selectedRegno; if (!regno) { setStatus("환자를 먼저 선택하세요", "err"); return; }
      const raw = document.getElementById("newLabABGA").value || "";
      const p = STATE.patients.get(regno); if (!p) { setStatus("선택된 환자를 찾을 수 없습니다.", "err"); return; }

      // Undo 저장 (ABGA Lab만)
      STATE.undo.set(regno, {
        ...STATE.undo.get(regno), // Preserve existing undo state for General Lab if any
        newRawABGA: p.newRawABGA,
        parsedABGAFields: { // Store only ABGA-related parsed fields for undo
          pH: p.parsed.pH, pCO2: p.parsed.pCO2, pO2: p.parsed.pO2,
          HCO3: p.parsed.HCO3, BE: p.parsed.BE, SaO2: p.parsed.SaO2, Lactate: p.parsed.Lactate
        },
        extrasAbga: p.extras?.abga // Store extras.abga for undo
      });

      const abgaData = parseABGALab(raw);

      // 1. Calculator용 수치 저장 (pH, pCO2 등)
      p.parsed = { ...p.parsed, ...abgaData.values };

      // 2. DOCX용 문자열 저장 (p.extras.abga) - 누적 (최신순, 최대 3줄)
      const prevFull = STATE.prevDocPatients.get(regno);
      const prevAbga = prevFull?.extras?.abga || "";

      p.extras = p.extras || {};

      if (abgaData.str) {
        // New data on top
        let combined = abgaData.str + "\n" + prevAbga;
        // Split, trim, filter empty, take top 3, join
        p.extras.abga = combined.split(/\r?\n/)
          .map(s => s.trim())
          .filter(Boolean)
          .slice(0, 3)
          .join("\n");
      } else {
        // No new data, keep existing (or clear if empty, but usually we want to keep history if just parsing failed)
        // If raw input was empty, maybe we shouldn't clear? 
        // But applyABGALab is called on input. If input is empty, abgaData.str is empty.
        // If user clears input, maybe they want to clear the *new* part?
        // But here we are managing the *persisted* ABGA string.
        // If input is empty, we probably shouldn't change p.extras.abga unless we want to reset.
        // However, the user's workflow is "Paste new data -> Stack".
        // If they paste nothing, nothing happens.
        // So if abgaData.str is empty, we just leave p.extras.abga as is (or reset to prevAbga if we consider this a "preview" of adding nothing).
        // Let's default to prevAbga if no new data is valid.
        if (!p.extras.abga) p.extras.abga = prevAbga;
      }

      p.newRawABGA = raw; // ABGA 원문 저장
      showPatient(regno);
    }

    function autoApplyGeneral() { if (_labTimer) clearTimeout(_labTimer); _labTimer = setTimeout(applyGeneralLab, 150); }
    function autoApplyABGA() { if (_abgaTimer) clearTimeout(_abgaTimer); _abgaTimer = setTimeout(applyABGALab, 150); }

    document.getElementById("newLabGeneral").addEventListener("input", autoApplyGeneral);
    document.getElementById("newLabGeneral").addEventListener("paste", autoApplyGeneral);

    document.getElementById("newLabABGA").addEventListener("input", autoApplyABGA);
    document.getElementById("newLabABGA").addEventListener("paste", autoApplyABGA);

    function undoLab() {
      const regno = STATE.selectedRegno;
      if (!regno || !STATE.undo.has(regno)) return;
      const prev = STATE.undo.get(regno);
      const p = STATE.patients.get(regno); if (!p) return;

      // Restore general lab
      if (prev.newRaw !== undefined) {
        p.newRaw = prev.newRaw;
        document.getElementById("newLabGeneral").value = p.newRaw || "";
      }
      if (prev.parsed) {
        // Restore general parsed fields, preserving current ABGA parsed fields
        const currentABGAFields = {};
        ['pH', 'pCO2', 'pO2', 'HCO3', 'BE', 'SaO2', 'Lactate'].forEach(f => {
          if (p.parsed[f] !== undefined) currentABGAFields[f] = p.parsed[f];
        });
        p.parsed = { ...prev.parsed, ...currentABGAFields };
      }

      // Restore ABGA lab
      if (prev.newRawABGA !== undefined) {
        p.newRawABGA = prev.newRawABGA;
        document.getElementById("newLabABGA").value = p.newRawABGA || "";
      }
      if (prev.parsedABGAFields) {
        // Restore ABGA parsed fields, preserving current general parsed fields
        const currentGeneralFields = {};
        for (const key in p.parsed) {
          if (!['pH', 'pCO2', 'pO2', 'HCO3', 'BE', 'SaO2', 'Lactate'].includes(key)) {
            currentGeneralFields[key] = p.parsed[key];
          }
        }
        p.parsed = { ...currentGeneralFields, ...prev.parsedABGAFields };
      }
      if (prev.extrasAbga !== undefined) {
        p.extras = p.extras || {};
        p.extras.abga = prev.extrasAbga;
      }

      // Clear undo state for this patient after restoring
      STATE.undo.delete(regno);

      showPatient(regno);
    }

    /* ===== DOCX 생성 (내용 7pt 저장 / 1열 넓힘 / 분할금지 / keepNext) ===== */
    async function generateDOCX() {
      if (STATE.patients.size === 0) return;

      const groups = new Map();
      for (const p of STATE.patients.values()) {
        const key = p.professor || "[주치의 미지정]";
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(p);
      }
      const profs = Array.from(groups.keys()).sort();

      const { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell, TableLayoutType, VerticalAlign, HeightRule, WidthType, ShadingType, BorderStyle } = docx;

      const P_SPACING = { before: 0, after: 0, line: 240 };
      const FONT = "Malgun Gothic";
      const makeRun = (text, sizeHalfPts, bold = false) => { const opt = { text: text ?? "", bold, font: FONT }; if (typeof sizeHalfPts === "number") opt.size = sizeHalfPts; return new TextRun(opt); };
      const makeP = (txt, sizeHalfPts, bold = false, keepNext = false) => new Paragraph({ spacing: P_SPACING, keepNext, children: [makeRun(txt, sizeHalfPts, bold)], run: { size: sizeHalfPts, font: FONT } });
      const makeParas = (text, sizeHalfPts, keepNext = false) => {
        const lines = String(text ?? "").split(/\r?\n/);
        if (lines.length === 1 && lines[0] === "") return [makeP("\u200B", sizeHalfPts, false, keepNext)]; // 빈칸도 5pt 유지
        return lines.map(t => makeP(t === "" ? "\u200B" : t, sizeHalfPts, false, keepNext)); // 내용 5pt
      };
      // 줄간격 좁게 (Problem List용)
      const makeTightParas = (text, sizeHalfPts) => {
        const lines = String(text ?? "").split(/\r?\n/);
        const tightSpacing = { before: 0, after: 0, line: 200 }; // Tighter than default 240
        if (lines.length === 1 && lines[0] === "") return [new Paragraph({ spacing: tightSpacing, children: [makeRun("\u200B", sizeHalfPts)], run: { size: sizeHalfPts, font: FONT } })];
        return lines.map(t => new Paragraph({ spacing: tightSpacing, children: [makeRun(t === "" ? "\u200B" : t, sizeHalfPts)], run: { size: sizeHalfPts, font: FONT } }));
      };

      const cellCommon = { margins: { top: 60, bottom: 60, left: 80, right: 80 }, verticalAlign: VerticalAlign.TOP };
      const SHADE = { type: ShadingType.CLEAR, fill: "EEEEEE", color: "auto" };

      // 본문 총 10800 twips: 1열 더 넓게 -> 1열 줄이고 2열 늘림 (사용자 요청)
      // Margins reduced to 1cm (567 twips) -> Total width ~10700 available.
      // 2500 + 2100 + 3000 + 1600 + 1600 = 10800. Fits.
      const COLS_TWIPS = [2500, 2100, 3000, 1600, 1600];

      const rows = [];
      for (const prof of profs) {
        rows.push(new TableRow({ // 교수 헤더(병합)
          children: [new TableCell({ children: [makeP(`[교수] ${prof}`, 20, true, true)], columnSpan: 5, shading: SHADE, ...cellCommon })],
          cantSplit: true
        }));
        const arr = groups.get(prof).slice().sort((a, b) => {
          const ka = roomSortKey(a.room), kb = roomSortKey(b.room);
          return (ka[0] < kb[0] ? -1 : ka[0] > kb[0] ? 1 : (ka[1] - kb[1]) || (ka[2] - kb[2]) || a.name.localeCompare(b.name, 'ko'));
        });

        for (const p of arr) {
          const ex = p.existing || {}; const parsed = p.parsed || {}; const extras = p.extras || {};
          const mergedLines = TEMPLATE_ORDER.map(lbl => {
            const base = ex[lbl] || ""; const nv = parsed[lbl] || "";
            if (!nv) return `${lbl} ${base}`;
            let toks = base ? base.split("→").map(s => s.trim()).filter(Boolean) : [];
            if (toks[toks.length - 1] !== nv) toks.push(nv);
            while (toks.length > 3) toks.shift();
            return `${lbl} ${toks.length ? toks.join("→") : nv}`;
          }).join("\n");
          const labBody = mergedLines + (p.existingTail ? ("\n" + p.existingTail) : "");
          const labFull = p.remind ? (labBody + "\n\n" + NOTE_TEXT) : labBody;

          // Bed No 처리
          const bedNoStr = p.bedNo ? `[${p.bedNo}] ` : "";
          // Oxygen String (Directly from oxyDetail which is now formatted)
          const oxyStr = extras.oxyDetail || "";

          // 1행(헤더 역할이었던 곳 → 이제 상단 데이터)
          // Col 1: [BedNo] Room Name SA RegNo (항상 병합 rowSpan:2)
          // Col 2: Oxygen Info (없으면 병합)
          // Col 3: ABGA (없으면 병합)
          // Col 4: (항상 병합)
          // Col 5: I/O Target (없으면 병합)

          // Nested Table Helper
          const createNestedTable = (topContent, bottomContent) => {
            return new Table({
              width: { size: 100, type: WidthType.PERCENTAGE },
              rows: [
                new TableRow({ children: [new TableCell({ children: topContent, ...cellCommon, borders: { bottom: { style: BorderStyle.SINGLE, size: 4, color: "auto" }, top: { style: BorderStyle.NONE }, left: { style: BorderStyle.NONE }, right: { style: BorderStyle.NONE } } })] }),
                new TableRow({ children: [new TableCell({ children: bottomContent, ...cellCommon, borders: { top: { style: BorderStyle.NONE }, bottom: { style: BorderStyle.NONE }, left: { style: BorderStyle.NONE }, right: { style: BorderStyle.NONE } } })] })
              ],
              borders: { top: { style: BorderStyle.NONE }, bottom: { style: BorderStyle.NONE }, left: { style: BorderStyle.NONE }, right: { style: BorderStyle.NONE }, insideHorizontal: { style: BorderStyle.SINGLE, size: 4, color: "auto" } }
            });
          };

          const hasOxy = !!oxyStr;
          const hasAbga = !!(extras.abga && extras.abga.trim());
          const hasIO = !!(extras.io && extras.io.trim());

          const mainRowCells = [];

          // Col 1: Name (Top) / Diag (Bottom) - Nested Table
          // No Shading
          const nameParas = [
            new Paragraph({
              spacing: P_SPACING, keepNext: true, children: [
                makeRun(bedNoStr, 15, true),
                makeRun(`${p.room || ""} `, 15, true),
                makeRun(`${p.name || ""}`, 15, true),
                makeRun(` ${p.sa || ""}`, 12, false), // 6pt
                makeRun(` ${p.regno || ""}`, 12, false), // 6pt
              ]
            })
          ];
          const diagParas = makeTightParas(extras.diag, 10);

          mainRowCells.push(new TableCell({
            children: [createNestedTable(nameParas, diagParas)],
            shading: { fill: "FFFFFF", val: ShadingType.CLEAR, color: "auto" }, // Explicitly White
            ...cellCommon
          }));

          // Col 2: Oxy (Top) / VS (Bottom)
          if (hasOxy) {
            mainRowCells.push(new TableCell({
              children: [createNestedTable([makeP(oxyStr, 10, true, true)], makeParas(extras.vs, 10))],
              ...cellCommon
            }));
          } else {
            mainRowCells.push(new TableCell({ children: makeParas(extras.vs, 10), ...cellCommon }));
          }

          // Col 3: ABGA (Top) / Lab (Bottom)
          if (hasAbga) {
            mainRowCells.push(new TableCell({
              children: [createNestedTable(makeParas(extras.abga, 10, true), makeParas(labFull, 10))],
              ...cellCommon
            }));
          } else {
            mainRowCells.push(new TableCell({ children: makeParas(labFull, 10), ...cellCommon }));
          }

          // Col 4: C4 (Single)
          mainRowCells.push(new TableCell({ children: makeParas(extras.c4, 10), ...cellCommon }));

          // Col 5: IO (Top) / C5 (Bottom)
          if (hasIO) {
            const ioContent = `I/O Target : ${extras.io}`;
            mainRowCells.push(new TableCell({
              children: [createNestedTable(makeParas(ioContent, 10, true), makeParas(extras.c5, 10))],
              ...cellCommon
            }));
          } else {
            mainRowCells.push(new TableCell({ children: makeParas(extras.c5, 10), ...cellCommon }));
          }

          rows.push(new TableRow({ children: mainRowCells, height: { value: 1200, rule: HeightRule.ATLEAST }, cantSplit: true }));
        }
      }

      const table = new Table({ layout: TableLayoutType.FIXED, width: { size: 100, type: WidthType.PERCENTAGE }, columnWidths: COLS_TWIPS, rows });
      const doc = new Document({ sections: [{ properties: { page: { margin: { top: 720, right: 567, bottom: 720, left: 567 } } }, children: [table] }] });
      const blob = await Packer.toBlob(doc);
      const dt = new Date(); const y = dt.getFullYear(), m = String(dt.getMonth() + 1).padStart(2, '0'), d = String(dt.getDate()).padStart(2, '0');
      const fname = `회진_${y}-${m}-${d}.docx`;

      if (STATE.saveDirHandle && window.isSecureContext && typeof STATE.saveDirHandle.getFileHandle === 'function') {
        try {
          const fh = await STATE.saveDirHandle.getFileHandle(fname, { create: true });
          const w = await fh.createWritable(); await w.write(blob); await w.close();
          setStatus(`DOCX 저장 완료(지정 폴더): ${fname}`, "ok");
        } catch (e) { setStatus("지정 폴더 저장 실패. 기본 다운로드로 전환: " + (e?.message || e), "err"); saveAs(blob, fname); }
      } else saveAs(blob, fname);
    }

    /* ===== 라이브 미리보기(편집 가능) ===== */
    function unifyPvdocHeights(grid) {
      if (!grid) return;
      const cs = getComputedStyle(grid);
      if (grid.offsetParent === null || cs.display === 'none' || cs.visibility === 'hidden') { requestAnimationFrame(() => unifyPvdocHeights(grid)); return; }

      const hdrCells = Array.from(grid.querySelectorAll('.cell.hdr'));
      hdrCells.forEach(c => c.style.height = 'auto'); let maxHdr = 0; hdrCells.forEach(c => { maxHdr = Math.max(maxHdr, c.scrollHeight); }); if (maxHdr < 24) maxHdr = 24; hdrCells.forEach(c => c.style.height = maxHdr + 'px');

      const tas = Array.from(grid.querySelectorAll('.cell:not(.hdr) textarea'));
      const MIN_TA = 120; let maxTA = 0;
      tas.forEach(t => { t.style.height = 'auto'; const h = Math.max(t.scrollHeight, MIN_TA); if (h > maxTA) maxTA = h; });
      if (maxTA < MIN_TA) maxTA = MIN_TA; tas.forEach(t => { t.style.height = maxTA + 'px'; });

      const bodyCells = Array.from(grid.querySelectorAll('.cell')).slice(5);
      bodyCells.forEach(c => c.style.height = 'auto'); let maxCell = 0;
      bodyCells.forEach(c => { maxCell = Math.max(maxCell, c.scrollHeight, maxTA); });
      if (maxCell < MIN_TA) maxCell = MIN_TA;
      bodyCells.forEach(c => c.style.height = maxCell + 'px');
    }
    function buildLabFullForPreview(p) {
      const ex = p.existing || {}; const parsed = p.parsed || {};
      const merged = TEMPLATE_ORDER.map(lbl => {
        const base = ex[lbl] || ""; const nv = parsed[lbl] || "";
        if (!nv) return `${lbl} ${base}`;
        let toks = base ? base.split("→").map(s => s.trim()).filter(Boolean) : [];
        if (toks[toks.length - 1] !== nv) toks.push(nv);
        while (toks.length > 3) toks.shift();
        return `${lbl} ${toks.length ? toks.join("→") : nv}`;
      }).join("\n");
      const tail = p.existingTail ? ("\n" + p.existingTail) : "";
      const body = merged + tail;
      return p.remind ? (body + "\n\n" + NOTE_TEXT) : body;
    }
    function renderLivePreview() {
      const root = document.getElementById("liveScroll"); if (!root) return;
      const groups = new Map();
      for (const p of STATE.patients.values()) { const key = p.professor || "[주치의 미지정]"; if (!groups.has(key)) groups.set(key, []); groups.get(key).push(p); }
      const profs = Array.from(groups.keys()).sort();
      const frag = document.createDocumentFragment();

      for (const prof of profs) {
        const h = document.createElement("div"); h.className = "pv-prof"; h.textContent = `[교수] ${prof}`; frag.appendChild(h);

        const arr = groups.get(prof).slice().sort((a, b) => {
          const ka = roomSortKey(a.room), kb = roomSortKey(b.room);
          return (ka[0] < kb[0] ? -1 : ka[0] > kb[0] ? 1 : (ka[1] - kb[1]) || (ka[2] - kb[2]) || a.name.localeCompare(b.name, 'ko'));
        });

        for (const p of arr) {
          const card = document.createElement("div"); card.className = "pv-card";
          const head = document.createElement("div"); head.className = "pv-head";
          head.innerHTML = `<span>${p.room || '-'} ${p.name || ''} ${p.sa || ''} ${p.regno || ''}</span>
      <label style="margin-left:auto;font-size:12px;color:#555;display:flex;align-items:center;gap:6px;">
        <input type="checkbox" class="pv-done" ${p.done ? 'checked' : ''}/> 완료
      </label>`;
          head.querySelector('.pv-done')?.addEventListener('change', () => { const pp = STATE.patients.get(p.regno); if (!pp) return; pp.done = !!head.querySelector('.pv-done').checked; renderPatientList(); });

          const grid = document.createElement("div"); grid.className = "pvdoc";

          const h1 = document.createElement("div"); h1.className = "cell hdr"; h1.innerHTML = `<span style="font-weight:700">${p.room || ''} ${p.name || ''}</span> ${p.sa || ''} ${p.regno || ''}`;
          const h2 = document.createElement("div"); h2.className = "cell hdr"; h2.textContent = "V/S";
          const h3 = document.createElement("div"); h3.className = "cell hdr"; h3.textContent = "lab";
          const h4 = document.createElement("div"); h4.className = "cell hdr"; h4.textContent = "";
          const h5 = document.createElement("div"); h5.className = "cell hdr"; h5.textContent = "";
          grid.append(h1, h2, h3, h4, h5);

          const b1 = document.createElement("div"); b1.className = "cell"; const t1 = document.createElement("textarea"); t1.value = p.extras?.diag || ""; t1.addEventListener("input", () => { const pp = STATE.patients.get(p.regno); if (!pp) return; pp.extras = pp.extras || {}; pp.extras.diag = t1.value; }); t1.addEventListener("input", () => unifyPvdocHeights(grid)); b1.appendChild(t1);
          const b2 = document.createElement("div"); b2.className = "cell"; const t2 = document.createElement("textarea"); t2.value = p.extras?.vs || ""; t2.addEventListener("input", () => { const pp = STATE.patients.get(p.regno); if (!pp) return; pp.extras = pp.extras || {}; pp.extras.vs = t2.value; }); t2.addEventListener("input", () => unifyPvdocHeights(grid)); b2.appendChild(t2);
          const b3 = document.createElement("div"); b3.className = "cell"; const t3 = document.createElement("textarea"); t3.value = buildLabFullForPreview(p);
          t3.addEventListener("input", () => { const txt = t3.value || ""; const blk = parseExistingBlock(txt); const pp = STATE.patients.get(p.regno); if (!pp) return; pp.existing = blk.map; pp.existingTail = blk.tail; pp.parsed = {}; refreshPreviewOnly(p.regno); });
          t3.addEventListener("input", () => unifyPvdocHeights(grid)); b3.appendChild(t3);
          const b4 = document.createElement("div"); b4.className = "cell"; const t4 = document.createElement("textarea"); t4.value = p.extras?.c4 || ""; t4.addEventListener("input", () => { const pp = STATE.patients.get(p.regno); if (!pp) return; pp.extras = pp.extras || {}; pp.extras.c4 = t4.value; }); t4.addEventListener("input", () => unifyPvdocHeights(grid)); b4.appendChild(t4);
          const b5 = document.createElement("div"); b5.className = "cell"; const t5 = document.createElement("textarea"); t5.value = p.extras?.c5 || ""; t5.addEventListener("input", () => { const pp = STATE.patients.get(p.regno); if (!pp) return; pp.extras = pp.extras || {}; pp.extras.c5 = t5.value; }); t5.addEventListener("input", () => unifyPvdocHeights(grid)); b5.appendChild(t5);

          grid.append(b1, b2, b3, b4, b5);
          unifyPvdocHeights(grid);

          card.appendChild(head); card.appendChild(grid); frag.appendChild(card);
        }
      }
      root.innerHTML = ""; root.appendChild(frag);
      requestAnimationFrame(() => { root.querySelectorAll('.pvdoc').forEach(unifyPvdocHeights); });
      const liveScr = document.getElementById("liveScroll"); if (liveScr) liveScr.querySelectorAll("textarea").forEach(bindWheelProxy);
    }
    function openLivePreview() { const m = document.getElementById("liveModal"); if (!m) return; m.classList.add("show"); requestAnimationFrame(() => { renderLivePreview(); requestAnimationFrame(() => { document.getElementById('liveScroll')?.querySelectorAll('.pvdoc').forEach(unifyPvdocHeights); }); }); }
    function closeLivePreview() { document.getElementById("liveModal")?.classList.remove("show"); }

    /* ===== 텍스트영역 위에서도 컨테이너 스크롤(모달/페이지 공통) ===== */
    function findScrollParent(el) {
      let p = el && el.parentElement;
      while (p) {
        const st = getComputedStyle(p);
        const oy = st.overflowY;
        const isScrollable = (oy === 'auto' || oy === 'scroll') && p.scrollHeight > p.clientHeight;
        if (isScrollable) return p;
        p = p.parentElement;
      }
      return document.scrollingElement || document.documentElement || document.body;
    }
    function bindWheelProxy(t) {
      if (!t) return;
      t.style.overflow = 'hidden';
      t.addEventListener('wheel', (e) => {
        e.preventDefault();
        const scroller = findScrollParent(t);
        if (scroller && scroller !== document.body && scroller !== document.documentElement) {
          scroller.scrollTop += e.deltaY;
        } else {
          window.scrollBy({ top: e.deltaY, left: 0, behavior: 'auto' });
        }
      }, { passive: false });
    }
    function attachProxyWheelToTextareas(scope = document) { scope.querySelectorAll('textarea').forEach(bindWheelProxy); }

    /* ===== 이벤트 ===== */
    document.getElementById("excelFile").addEventListener("change", async (e) => {
      const f = e.target.files[0];
      if (!f) { setStatus("엑셀이 선택되지 않았습니다.", "err"); return; }
      try {
        await loadExcel(f);
        setStatus(`엑셀 로드 완료: ${f.name}`, "ok");
        renderPatientList();
      } catch (err) {
        setStatus("엑셀 파일 읽기 실패: " + (err?.message || err), "err");
      } finally {
        // 같은 파일을 다시 골라도 change가 동작하도록 초기화
        e.target.value = "";
      }
    });
    document.getElementById("docxFile").addEventListener("change", async (e) => {
      const f = e.target.files[0];
      if (!f) { setStatus("DOCX가 선택되지 않았습니다.", "err"); return; }
      try {
        STATE.prevDocPatients.clear();
        await parsePreviousDocx(f);
        for (const [regno, prev] of STATE.prevDocPatients) {
          if (STATE.patients.has(regno)) {
            const tgt = STATE.patients.get(regno);
            tgt.existing = prev?.existing || {};
            tgt.existingTail = prev?.existingTail || "";
            if (typeof prev.remind === "boolean") tgt.remind = prev.remind;
            if (prev.extras) tgt.extras = { ...(tgt.extras || {}), ...(prev.extras || {}) };
          }
        }
        setStatus(`직전 회진표 로드 완료: ${f.name}`, "ok");
        renderPatientList();
      } catch (err) {
        setStatus("DOCX 읽기 실패: " + (err?.message || err), "err");
      } finally {
        // 같은 파일을 다시 골라도 change가 동작하도록 초기화
        e.target.value = "";
      }
    });
    document.getElementById("btnUndo").addEventListener("click", undoLab);
    document.getElementById("btnRemind").addEventListener("click", () => {
      const regno = STATE.selectedRegno; if (!regno) { setStatus("환자를 먼저 선택하세요", "err"); return; }
      const p = STATE.patients.get(regno); if (!p) { setStatus("선택된 환자를 찾을 수 없습니다.", "err"); return; }
      p.remind = !p.remind; showPatient(regno);
    });
    document.getElementById("btnGenerate").addEventListener("click", generateDOCX);
    document.getElementById("btnLivePreview").addEventListener("click", openLivePreview);
    document.getElementById("btnClosePreview").addEventListener("click", closeLivePreview);
    document.getElementById("btnPickDir").addEventListener("click", async () => {
      if (!window.showDirectoryPicker) { setStatus("이 브라우저는 폴더 선택을 지원하지 않습니다. (Chrome/Edge 권장)", "err"); return; }
      try { const dir = await window.showDirectoryPicker(); STATE.saveDirHandle = dir; setStatus("저장 폴더가 설정되었습니다.", "ok"); }
      catch (e) { if (e && e.name === "AbortError") return; setStatus("폴더 선택 실패: " + (e?.message || e), "err"); }
    });

    /* 초기 바인딩 */
    window.addEventListener("load", () => {
      attachProxyWheelToTextareas(document);
      ['existingLabInput', 'diagText', 'vsText', 'c4Text', 'c5Text', 'newLabGeneral', 'newLabABGA', 'abgaText', 'ioText'].forEach(id => { const el = document.getElementById(id); if (el) bindAutoGrow(el); });
    });

    /* ===== Oxygen / Vent Logic ===== */
    let currentOxyMode = "RA";

    const OXY_MODES = {
      "RA": {},
      "Nasal": { inputs: ['oxy_nasal_l'], fio2Calc: (l) => 20 + 4 * (parseFloat(l) || 0) },
      "RM": { inputs: ['oxy_rm_l'], fio2Calc: (l) => { const val = parseFloat(l); if (val >= 10) return Math.min(100, 60 + (val - 10) * 8); if (val > 0) return 40 + (val * 2); return 0; } },
      "HFNC": { inputs: ['oxy_hfnc_flow', 'oxy_hfnc_fio2'] },
      "Vent": {
        inputs: ['oxy_vent_mode', 'v_fio2', 'v_rr', 'v_vt', 'v_peep', 'v_ps', 'v_pinsp', 'v_ie', 'v_ipap', 'v_epap'],
        fieldsBySubMode: {
          'AC-VC': ['.v-fio2', '.v-rr', '.v-vt', '.v-peep'],
          'AC-PC': ['.v-fio2', '.v-rr', '.v-pinsp', '.v-peep', '.v-ie'],
          'SIMV-VC': ['.v-fio2', '.v-rr', '.v-vt', '.v-peep', '.v-ps'],
          'SIMV-PC': ['.v-fio2', '.v-rr', '.v-pinsp', '.v-peep', '.v-ps'],
          'PSV': ['.v-fio2', '.v-ps', '.v-peep'],
          'CPAP': ['.v-fio2', '.v-peep', '.v-ps'],
          'BiPAP': ['.v-fio2', '.v-ipap', '.v-epap']
        }
      },
      "T-piece": { inputs: ['oxy_other_detail'] },
      "Trach": { inputs: ['oxy_other_detail'] }
    };

    function setOxyMode(mode) {
      currentOxyMode = mode;
      // Hide all new panels
      document.querySelectorAll('.oxy-panel-new').forEach(el => el.style.display = 'none');

      // Update active button state
      document.querySelectorAll('.oxy-btn-new').forEach(btn => {
        if (btn.textContent === mode) btn.classList.add('active');
        else btn.classList.remove('active');
      });

      if (mode === 'Nasal') document.getElementById('oxyPanel_Nasal').style.display = 'block';
      else if (mode === 'RM') document.getElementById('oxyPanel_RM').style.display = 'block';
      else if (mode === 'HFNC') document.getElementById('oxyPanel_HFNC').style.display = 'block';
      else if (mode === 'Vent') {
        document.getElementById('oxyPanel_Vent').style.display = 'block';
        updateVentFields();
      }
      else if (mode === 'T-piece' || mode === 'Trach') document.getElementById('oxyPanel_Other').style.display = 'block';

      updateOxyString();
    }

    function updateOxyString() {
      const regno = STATE.selectedRegno; if (!regno) return;
      const p = STATE.patients.get(regno); if (!p) return;

      let str = "";
      const data = {}; // Raw data to save

      if (currentOxyMode === 'RA') {
        str = "RA";
      } else if (currentOxyMode === 'Nasal') {
        const l = document.getElementById('oxy_nasal_l').value;
        const fio2 = OXY_MODES.Nasal.fio2Calc(l);
        document.getElementById('oxy_nasal_fio2_disp').textContent = `(FiO₂ ${fio2}%)`;
        if (l) str = `Nasal ${l}L (FiO₂ ${fio2}%)`;
        data.nasal_l = l;
      } else if (currentOxyMode === 'RM') {
        const l = document.getElementById('oxy_rm_l').value;
        const fio2 = OXY_MODES.RM.fio2Calc(l);
        document.getElementById('oxy_rm_fio2_disp').textContent = `(FiO₂ ${fio2}%)`;
        if (l) str = `RM ${l}L (FiO₂ ${fio2}%)`;
        data.rm_l = l;
      } else if (currentOxyMode === 'HFNC') {
        const flow = document.getElementById('oxy_hfnc_flow').value;
        const fio2Pct = document.getElementById('oxy_hfnc_fio2').value; // Integer percent (e.g. 40)
        const fio2 = (parseFloat(fio2Pct) / 100) || 0; // Convert to 0.4
        // Output format: HFNC 40/0.4
        // If fio2 is 1, show 1.0? User example 0.4.
        if (flow && fio2Pct) str = `HFNC ${flow}/${fio2}`;
        data.hfnc_flow = flow; data.hfnc_fio2 = fio2Pct; // Save as percent
      } else if (currentOxyMode === 'Vent') {
        const mode = document.getElementById('oxy_vent_mode').value;
        const fio2 = document.getElementById('v_fio2').value;
        const rr = document.getElementById('v_rr').value;
        const vt = document.getElementById('v_vt').value;
        const peep = document.getElementById('v_peep').value;
        const ps = document.getElementById('v_ps').value;
        const pinsp = document.getElementById('v_pinsp').value;
        const ie = document.getElementById('v_ie').value;
        const ipap = document.getElementById('v_ipap').value;
        const epap = document.getElementById('v_epap').value;

        // Format based on mode
        if (mode === 'AC-VC') str = `AC-VC, FiO₂ ${fio2}, RR ${rr}, VT ${vt}, PEEP ${peep}`;
        else if (mode === 'AC-PC') str = `AC-PC, FiO₂ ${fio2}, RR ${rr}, Pinsp ${pinsp}, PEEP ${peep}, I:E 1:${ie}`;
        else if (mode === 'SIMV-VC') str = `SIMV-VC, FiO₂ ${fio2}, RR ${rr}, VT ${vt}, PEEP ${peep}, PS ${ps}`;
        else if (mode === 'SIMV-PC') str = `SIMV-PC, FiO₂ ${fio2}, RR ${rr}, Pinsp ${pinsp}, PEEP ${peep}, PS ${ps}`;
        else if (mode === 'PSV') str = `PSV, FiO₂ ${fio2}, PS ${ps}, PEEP ${peep}`;
        else if (mode === 'CPAP') str = `CPAP, FiO₂ ${fio2}, PEEP ${peep}` + (ps ? `, PS ${ps}` : "");
        else if (mode === 'BiPAP') str = `BiPAP ${ipap}/${epap}, FiO₂ ${fio2}`;

        data.vent_mode = mode; data.v_fio2 = fio2; data.v_rr = rr; data.v_vt = vt; data.v_peep = peep;
        data.v_ps = ps; data.v_pinsp = pinsp; data.v_ie = ie; data.v_ipap = ipap; data.v_epap = epap;
      } else if (currentOxyMode === 'T-piece' || currentOxyMode === 'Trach') {
        const det = document.getElementById('oxy_other_detail').value;
        str = `${currentOxyMode} ${det}`;
        data.other_detail = det;
      }

      document.getElementById('oxyPreview').textContent = str;

      // Save to patient
      p.extras = p.extras || {};
      p.extras.oxyDetail = str; // For DOCX
      p.extras.oxyMode = currentOxyMode;
      p.extras.oxyData = data; // Raw data
    }

    // Bind inputs
    function bindOxyInputs() {
      const ids = ['oxy_nasal_l', 'oxy_rm_l', 'oxy_hfnc_flow', 'oxy_hfnc_fio2', 'v_fio2', 'v_rr', 'v_vt', 'v_peep', 'v_ps', 'v_pinsp', 'v_ie', 'v_ipap', 'v_epap', 'oxy_other_detail'];
      ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('input', updateOxyString);
      });
      const vMode = document.getElementById('oxy_vent_mode');
      if (vMode) vMode.addEventListener('change', () => {
        updateVentFields();
        updateOxyString();
      });
    }

    function updateVentFields() {
      const mode = document.getElementById('oxy_vent_mode').value;
      const show = (cls) => document.querySelectorAll(cls).forEach(e => e.style.display = 'flex'); // Use flex for v-item
      const hide = (cls) => document.querySelectorAll(cls).forEach(e => e.style.display = 'none');

      // Hide all first
      document.querySelectorAll('.v-item').forEach(e => e.style.display = 'none');

      // Common
      show('.v-fio2');

      if (mode === 'AC-VC') { show('.v-rr'); show('.v-vt'); show('.v-peep'); }
      else if (mode === 'AC-PC') { show('.v-rr'); show('.v-pinsp'); show('.v-peep'); show('.v-ie'); }
      else if (mode === 'SIMV-VC') { show('.v-rr'); show('.v-vt'); show('.v-peep'); show('.v-ps'); }
      else if (mode === 'SIMV-PC') { show('.v-rr'); show('.v-pinsp'); show('.v-peep'); show('.v-ps'); }
      else if (mode === 'PSV') { show('.v-ps'); show('.v-peep'); }
      else if (mode === 'CPAP') { show('.v-peep'); show('.v-ps'); }
      else if (mode === 'BiPAP') { show('.v-ipap'); show('.v-epap'); }
    }

    window.addEventListener("load", () => {
      bindOxyInputs();
      // ... existing load ...
    });

    function setIO(val) {
      const el = document.getElementById('ioText');
      if (el) { el.value = val; el.dispatchEvent(new Event('input')); }
    }
    function adjustIO(delta) {
      const el = document.getElementById('ioText');
      if (!el) return;
      let val = el.value.trim();
      if (val === 'Even') {
        val = delta > 0 ? '+100' : '-100';
      } else if (val === '') {
        val = delta > 0 ? '+100' : '-100';
      } else {
        // 숫자 파싱
        // "+100", "-200", "300" 등
        let num = parseInt(val.replace(/[^\d-]/g, ''), 10);
        if (isNaN(num)) num = 0;
        num += delta;
        val = (num > 0 ? '+' : '') + num;
        if (num === 0) val = 'Even';
      }
      el.value = val;
      el.dispatchEvent(new Event('input'));
    }

    /* ===== 고급계산 — 상태 ===== */
    // ⚠️주의: 전역 STATE.calc는 더 이상 사용하지 않습니다(하위호환만 유지).
    // 각 환자별 계산값은 p.calc에 저장합니다(serumText/abgaText/urineText/fluidText, 파싱결과, ULN, current 등).
    STATE.calc = { current: null, serumText: "", abgaText: "", urineText: "", fluidText: "", serum: {}, abga: {}, urine: {}, fluid: {}, uln: {} };

    /* ===== 고급계산 — 도우미 ===== */
    function _toNum(v) { if (v === null || v === undefined) return NaN; const s = String(v).replace(/[,\s]/g, ""); const n = Number(s); return isFinite(n) ? n : NaN; }
    function _fmt(n, d = 1) { if (n === null || n === undefined || Number.isNaN(n)) return ""; return (d === 0 ? Math.round(n) : Number(n).toFixed(d)); }
    function _lnCap(x) { const n = _toNum(x); if (!isFinite(n) || n <= 0) return Math.log(1.0); return Math.log(n < 1 ? 1 : n); }
    function _getAgeFromSA(sa) { // e.g., "F/67"
      if (!sa) return NaN; const m = String(sa).match(/\/(\d{1,3})/); return m ? Number(m[1]) : NaN;
    }

    function _splitSlash3(s) { // "a/b/c" → [a,b,c]
      if (!s) return ["", "", ""]; const t = String(s).split("/").map(x => x.trim()); return [t[0] || "", t[1] || "", t[2] || ""];
    }
    function _splitSlash2(s) { if (!s) return ["", ""]; const t = String(s).split("/").map(x => x.trim()); return [t[0] || "", t[1] || ""]; }

    // 기존 누적 포맷에서 가장 최신(우측) 값만 추출 (예: "a→b→c" → "c")
    function _latestPiece(s) { if (!s) return ""; const t = String(s).split("→"); return t[t.length - 1].trim(); }

    // 현재 선택 환자의 per-patient calc 상태 보장 생성/반환
    function _getCalcStateFor(regno) {
      const p = STATE.patients.get(regno) || STATE.prevDocPatients.get(regno);
      if (!p) return null;
      if (!p.calc) { p.calc = { current: null, serumText: "", abgaText: "", urineText: "", fluidText: "", serum: {}, abga: {}, urine: {}, fluid: {}, uln: {} }; }
      // 누락 필드 보정(이전 버전과의 호환)
      p.calc.current = (typeof p.calc.current !== "string" && p.calc.current !== null) ? null : p.calc.current;
      ["serum", "abga", "urine", "fluid", "uln"].forEach(k => { if (!p.calc[k]) p.calc[k] = {}; });
      ["serumText", "abgaText", "urineText", "fluidText"].forEach(k => { if (typeof p.calc[k] !== "string") p.calc[k] = ""; });
      return p.calc;
    }

    /* Extract ULN from current pasted new-lab raw (ranges like a~b) */
    function _scanULNFromNewLab(raw) { const u = {}; const lines = (raw || "").split(/\r?\n/); const grab = (re, key) => { for (const L of lines) { const s = (L || "").replace(/\s+/g, ' ').trim(); if (re.test(s)) { const m = s.match(/(\d+(?:\.\d+)?)\s*~\s*(\d+(?:\.\d+)?)/); if (m) u[key] = _toNum(m[2]); } } }; grab(/AST\s*\(GOT\)/i, 'ULN_AST'); grab(/LDH\b(?!.*Body)/i, 'ULN_LDH'); grab(/GGT|γ-?GTP/i, 'ULN_GGT'); return u; }

    function _collectSerumFromState(p) {
      const ex = p?.existing || {}; const pr = p?.parsed || {}; const out = {};
      const latest = (s) => _latestPiece(s || "");

      const take3 = (lbl, keys) => { const raw = pr[lbl] || (ex[lbl] ? latest(ex[lbl]) : ""); const [a, b, c] = _splitSlash3(raw); out[keys[0]] = _toNum(a); out[keys[1]] = _toNum(b); out[keys[2]] = _toNum(c); };
      const take2 = (lbl, keys) => { const raw = pr[lbl] || (ex[lbl] ? latest(ex[lbl]) : ""); const [a, b] = _splitSlash2(raw); out[keys[0]] = _toNum(a); out[keys[1]] = _toNum(b); };

      take3("Na/K/Cl :", ["Na", "K", "Cl"]);
      take2("BUN/Cr :", ["BUN", "Cr"]);
      take2("AST/ALT:", ["AST", "ALT"]);
      take2("gGT/ALP :", ["GGT", "ALP"]);
      take2("TB/DB:", ["TBil", "DBil"]);
      take2("TP/Alb :", ["TP", "Alb"]);

      const inrRaw = pr["PT(INR) :"] || (ex["PT(INR) :"] ? latest(ex["PT(INR) :"]) : "");
      out.INR = _toNum(inrRaw);

      // CBC 세부 (CBC : WBC/Hb/Plt 형태 또는 _CBC_DETAILS)
      const d = pr["_CBC_DETAILS"] || {};
      if (d) { out.Hb = _toNum(d.Hb_g_dl || ""); out.MCV = _toNum(d.MCV_fL || ""); out.RBC_mil = _toNum(d.RBC_10e12_perL || ""); out.RDW = _toNum(d.RDW_pct || ""); out.MCHC = _toNum(d.MCHC_g_dl || ""); out.WBC = _toNum(d.WBC_per_uL || ""); out.Plt = _toNum(d.Plt_per_uL || ""); }
      // CBC 콤팩트에서 보조 추출 (누적 포맷 고려)
      if (!isFinite(out.Hb) || !isFinite(out.Plt)) {
        const rawCBC = pr["CBC :"] || (ex["CBC :"] ? latest(ex["CBC :"]) : "");
        if (rawCBC) { const [w, hb, plt] = _splitSlash3(rawCBC); if (!isFinite(out.Hb)) out.Hb = _toNum(hb); if (!isFinite(out.Plt)) out.Plt = _toNum(plt); }
      }

      // Total CO2 (serum) fallback → HCO3 보조
      try {
        const lines = (p?.newRaw || "").split(/\r?\n/).map(s => s.trim());
        const hit = lines.find(L => /^Total\s+CO2\b/i.test((L || "")));
        if (hit) { const m = hit.match(/-?\d+(?:\.\d+)?/); if (m) out.TCO2 = _toNum(m[0]); }
      } catch (_) { }

      return out;
    }

    /* Parse ABGA pasted text */
    function _parseABGA(text) {
      const lines = (text || "").split(/\r?\n/).map(s => s.replace(/\t/g, ' ').replace(/\s+/g, ' ').trim()).filter(Boolean);
      const firstNum = (s) => { const m = String(s || '').match(/([<>]=?\s*)?-?\d+(?:\.\d+)?/); return m ? _toNum(m[0].replace(/\s+/g, '')) : NaN; };
      const get = (label) => { const L = lines.find(x => x.startsWith(label)); if (!L) return { val: NaN }; const tail = L.slice(label.length).trim(); return { val: firstNum(tail) }; };
      const out = {}; let t;
      t = get('ABGA-PH'); if (isFinite(t.val)) out.pH = t.val;
      t = get('ABGA-PCO2'); if (isFinite(t.val)) out.pCO2 = t.val;
      t = get('ABGA-HCO3'); if (isFinite(t.val)) out.HCO3 = t.val;
      t = get('Total CO₂(Calculation)'); if (isFinite(t.val)) out.ABG_TCO2 = t.val;
      t = get('Sodium (Blood Gas)'); if (isFinite(t.val)) out.Na_bg = t.val;
      t = get('Potassium (Blood Gas)'); if (isFinite(t.val)) out.K_bg = t.val;
      t = get('Chloride (Blood Gas)'); if (isFinite(t.val)) out.Cl_bg = t.val;
      t = get('Lactic Acid'); if (isFinite(t.val)) out.Lactate = t.val;
      t = get('Hemoglobin (Blood Gas)'); if (isFinite(t.val)) out.Hb_bg = t.val;
      t = get('Glucose (Blood Gas)'); if (isFinite(t.val)) out.Glu_bg = t.val;
      t = get('Ionized-Calcium'); if (isFinite(t.val)) out.iCa = t.val;
      return out;
    }

    /* Parse Urine pasted text */
    function _parseUrine(text) {
      const lines = (text || "").split(/\r?\n/).map(s => s.replace(/\t/g, ' ').replace(/\s+/g, ' ').trim()).filter(Boolean);
      const firstNum = (s) => { const m = String(s || '').match(/([<>]=?\s*)?-?\d+(?:\.\d+)?/); return m ? _toNum(m[0].replace(/\s+/g, '')) : NaN; };
      const get = (label) => { const L = lines.find(x => x.startsWith(label)); if (!L) return { val: NaN }; const tail = L.slice(label.length).trim(); return { val: firstNum(tail) }; };
      const out = {}; let t;
      t = get('Urea Nitrogen (Urine)'); if (isFinite(t.val)) out.U_BUN = t.val;
      t = get('Creatinine (Urine)'); if (isFinite(t.val)) out.U_Cr = t.val;
      t = get('Sodium (Urine)'); if (isFinite(t.val)) out.U_Na = t.val;
      t = get('Potassium (Urine)'); if (isFinite(t.val)) out.U_K = t.val;
      t = get('Osmolality (Urine)'); if (isFinite(t.val)) out.U_Osm = t.val;
      return out;
    }
    /* Parse Body Fluid pasted text (흉수/복수 공통) */
    function _parseFluid(text) { const m = {}; const lines = (text || "").split(/\r?\n/); const get = (re, k) => { for (const L of lines) { const s = (L || "").replace(/\s+/g, ' ').trim(); if (re.test(s)) { const r = s.match(/-?\d+(?:\.\d+)?/); if (r) { m[k] = _toNum(r[0]); break; } } } }; get(/^Total\s+Protein\b/i, 'BF_TP'); get(/^LDH\b/i, 'BF_LDH'); get(/^Albumin\b.*\(Body fluid\)/i, 'BF_Alb'); return m; }

    /* Parse Serum pasted text for calc modal (재사용: parseGeneralLab → 수치만 추출) */
    function _parseSerumToCalc(text) {
      const lines = (text || "").split(/\r?\n/).map(s => s.replace(/\t/g, ' ').replace(/\s+/g, ' ').trim()).filter(Boolean);
      const firstNum = (s) => { const m = String(s || '').match(/([<>]=?\s*)?-?\d+(?:\.\d+)?/); return m ? _toNum(m[0].replace(/\s+/g, '')) : NaN; };
      const get = (label) => { const L = lines.find(x => { const s = x.trim(); return s.startsWith(label) || s.startsWith('‥' + label); }); if (!L) return { val: NaN, uln: NaN }; const tail = L.replace(label, '').replace('‥', '').trim(); const v = firstNum(tail); const r = tail.match(/(\d+(?:\.\d+)?)\s*~\s*(\d+(?:\.\d+)?)/); const u = r ? _toNum(r[2]) : NaN; return { val: v, uln: u }; };
      const out = {}; let t;
      // Ferritin
      t = get('Ferritin'); if (isFinite(t.val)) out.Ferritin = t.val;
      t = get('PT(sec)'); if (isFinite(t.val)) out.PT_sec = t.val;
      // Reticulocyte block (CBC 보고서의 C.Reti(%)&IRF)
      t = get('Reticulocyte(%)'); if (isFinite(t.val)) out.Reticulocyte = t.val;
      t = get('Corrected Reti.(%)'); if (isFinite(t.val)) out.Corrected_Reti = t.val;
      t = get('Immature Reticulocyte Fraction (IRF)'); if (isFinite(t.val)) out.IRF = t.val;
      // Anemia panel
      t = get('Vitamin B12'); if (isFinite(t.val)) out.B12 = t.val;
      t = get('Folate'); if (isFinite(t.val)) out.Folate = t.val;

      // CBC
      t = get('WBC'); if (isFinite(t.val)) out.WBC = Math.trunc(t.val * 1000);
      t = get('RBC'); if (isFinite(t.val)) out.RBC_mil = t.val;
      t = get('Hemoglobin(Hb)'); if (isFinite(t.val)) out.Hb = t.val;
      t = get('Hematocrit(Hct)'); if (isFinite(t.val)) out.Hct = t.val;
      t = get('‥MCV'); if (isFinite(t.val)) out.MCV = t.val;
      t = get('‥MCH'); if (isFinite(t.val)) out.MCH = t.val;
      t = get('‥MCHC'); if (isFinite(t.val)) out.MCHC = t.val;
      t = get('RDW'); if (isFinite(t.val)) out.RDW = t.val;
      t = get('Platelet'); if (isFinite(t.val)) out.Plt = Math.trunc(t.val * 1000);
      t = get('‥ANC'); if (isFinite(t.val)) out.ANC = t.val;

      // Chemistry
      t = get('Total Protein'); if (isFinite(t.val)) out.TP = t.val;
      t = get('Albumin'); if (isFinite(t.val)) out.Alb = t.val;
      t = get('Glucose'); if (isFinite(t.val)) out.Glu = t.val;
      t = get('Total Bilirubin'); if (isFinite(t.val)) out.TBil = t.val;
      t = get('Direct Bilirubin'); if (isFinite(t.val)) out.DBil = t.val;
      t = get('Urea Nitrogen'); if (isFinite(t.val)) out.BUN = t.val;
      t = get('Creatinine'); if (isFinite(t.val)) out.Cr = t.val;
      t = get('Uric acid'); if (isFinite(t.val)) out.UA = t.val;
      t = get('AST(GOT)'); if (isFinite(t.val)) out.AST = t.val; if (isFinite(t.uln)) out.ULN_AST = t.uln;
      t = get('ALT(GPT)'); if (isFinite(t.val)) out.ALT = t.val;
      t = get('LDH'); if (isFinite(t.val)) out.LDH = t.val; if (isFinite(t.uln)) out.ULN_LDH = t.uln;
      t = get('γ-GTP(GGT)'); if (isFinite(t.val)) out.GGT = t.val; if (isFinite(t.uln)) out.ULN_GGT = t.uln;
      t = get('ALP(Alkaline Phosphatase)'); if (isFinite(t.val)) out.ALP = t.val;
      t = get('I.Phosphorus'); if (isFinite(t.val)) out.Phos = t.val;
      t = get('Calcium'); if (isFinite(t.val)) out.Ca = t.val;
      t = get('Sodium'); if (isFinite(t.val)) out.Na = t.val;
      t = get('Potassium'); if (isFinite(t.val)) out.K = t.val;
      t = get('Chloride'); if (isFinite(t.val)) out.Cl = t.val;
      t = get('Magnesium'); if (isFinite(t.val)) out.Mg = t.val;
      t = get('Total CO2'); if (isFinite(t.val)) out.TCO2 = t.val; // HCO3 보조
      t = get('CK'); if (isFinite(t.val)) out.CK = t.val;
      t = get('Amylase'); if (isFinite(t.val)) out.Amy = t.val;
      t = get('Lipase'); if (isFinite(t.val)) out.Lip = t.val;
      t = get('Iron(Fe)'); if (isFinite(t.val)) out.Fe = t.val;
      t = get('TIBC'); if (isFinite(t.val)) out.TIBC = t.val;
      t = get('‥Transferrin Saturation'); if (isFinite(t.val)) out.TSAT = t.val;
      t = get('CRP'); if (isFinite(t.val)) out.CRP = t.val;

      return out;
    }

    /* Build seed Serum text from current state (existing/parsed) when newRaw is absent */
    function _seedSerumTextFromState(p) {
      if (!p) return "";
      const pr = p.parsed || {};
      const ex = p.existing || {};
      const take = (lbl) => (pr[lbl] || ex[lbl] || "");
      const lines = [];
      // Na/K/Cl
      (function () {
        const t = (take("Na/K/Cl :") || "").split('/').map(s => s.trim());
        if (t[0]) lines.push(`Sodium ${t[0]} mEq/L`);
        if (t[1]) lines.push(`Potassium ${t[1]} mEq/L`);
        if (t[2]) lines.push(`Chloride ${t[2]} mEq/L`);
      })();
      // BUN/Cr
      (function () {
        const t = (take("BUN/Cr :") || "").split('/').map(s => s.trim());
        if (t[0]) lines.push(`Urea Nitrogen ${t[0]} mg/dL`);
        if (t[1]) lines.push(`Creatinine ${t[1]} mg/dL`);
      })();
      // AST/ALT
      (function () {
        const t = (take("AST/ALT:") || "").split('/').map(s => s.trim());
        if (t[0]) lines.push(`AST(GOT) ${t[0]} IU/L`);
        if (t[1]) lines.push(`ALT(GPT) ${t[1]} IU/L`);
      })();
      // TB/DB
      (function () {
        const t = (take("TB/DB:") || "").split('/').map(s => s.trim());
        if (t[0]) lines.push(`Total Bilirubin ${t[0]} mg/dL`);
        if (t[1]) lines.push(`Direct Bilirubin ${t[1]} mg/dL`);
      })();
      // TP/Alb
      (function () {
        const t = (take("TP/Alb :") || "").split('/').map(s => s.trim());
        if (t[0]) lines.push(`Total Protein ${t[0]} g/dL`);
        if (t[1]) lines.push(`Albumin ${t[1]} g/dL`);
      })();
      // gGT/ALP
      (function () {
        const t = (take("gGT/ALP :") || "").split('/').map(s => s.trim());
        if (t[0]) lines.push(`γ-GTP(GGT) ${t[0]} IU/L`);
        if (t[1]) lines.push(`ALP(Alkaline Phosphatase) ${t[1]} IU/L`);
      })();
      // INR
      (function () {
        const inr = (pr["PT(INR) :"] || ex["PT(INR) :"] || "").toString().trim();
        if (inr) lines.push(`PT (INR) ${inr}`);
      })();
      // Total CO2 (if present in newRaw tail)
      try {
        const raw = (p.newRaw || "").split(/\r?\n/);
        const hit = raw.find(L => /^Total\s+CO2\b/i.test((L || "").trim()));
        if (hit) lines.push(hit.trim());
      } catch (_) { }
      return lines.join("\n");
    }

    function _collectAllForCalc() {
      const reg = STATE.selectedRegno;
      const p = STATE.patients.get(reg) || STATE.prevDocPatients.get(reg);
      const base = _collectSerumFromState(p || {}); // 기존 parsed/existing
      const fromNewRaw = _parseSerumToCalc(p?.newRaw || '');
      const calc = _getCalcStateFor(reg) || { serum: {}, abga: {}, urine: {}, fluid: {}, uln: {} };

      const all = { ...base, ...fromNewRaw, ...calc.serum, ...calc.abga, ...calc.urine, ...calc.fluid, ...calc.uln };
      if (!isFinite(all.HCO3) && isFinite(all.ABG_TCO2)) all.HCO3 = all.ABG_TCO2;

      if (!isFinite(all.S_Osm)) {
        const calcOsm = (isFinite(all.Na) && isFinite(all.Glu) && isFinite(all.BUN)) ? (2 * all.Na + all.Glu / 18 + all.BUN / 2.8) : NaN;
        all.S_Osm = calcOsm;
      }

      const age = _getAgeFromSA(p?.sa); if (isFinite(age)) all.Age = age;
      if (!isFinite(all.ULN_ALT)) {
        all.ULN_ALT = 40;
      }
      if (!isFinite(all.ULN_ALP)) {
        all.ULN_ALP = 120;
      }
      if (!isFinite(all.PT_control)) {
        all.PT_control = 12;
      }
      return all;
    }

    /* ===== 계산기 정의 ===== */
    const CALC_DEFS = [
      { id: 'FENa', name: 'FENa', fields: ['U_Na', 'Na', 'U_Cr', 'Cr'], compute: calcFENa },
      { id: 'FEUrea', name: 'FEUrea', fields: ['U_BUN', 'BUN', 'U_Cr', 'Cr'], compute: calcFEUrea },
      { id: 'anemia', name: '빈혈패턴분석', fields: ['Hb', 'MCV', 'RBC_mil', 'RDW', 'MCHC', 'Fe', 'TIBC', 'TSAT', 'B12', 'Folate', 'Ferritin', 'Reticulocyte', 'IRF', 'Corrected_Reti'], compute: calcAnemia },
      { id: 'child', name: 'Child-Pugh score', fields: ['TBil', 'Alb', 'INR', 'Ascites', 'Enceph'], compute: calcChildPugh },
      { id: 'rfactor', name: 'R-factor', fields: ['ALT', 'ULN_ALT', 'ALP', 'ULN_ALP'], compute: calcRFactor },
      { id: 'maddrey', name: 'Maddrey DF', fields: ['PT_sec', 'PT_control', 'TBil'], compute: calcMaddrey },
      { id: 'meld', name: 'MELD score', fields: ['Cr', 'TBil', 'INR', 'Na', 'Dialysis'], compute: calcMELD },
      { id: 'lights', name: "Light's Criteria", fields: ['BF_TP', 'TP', 'BF_LDH', 'LDH', 'ULN_LDH'], compute: calcLights },
      { id: 'SAAG', name: 'SAAG', fields: ['Alb', 'BF_Alb'], compute: calcSAAG },
      { id: 'abga_anal', name: 'ABGA Analysis', fields: ['pH', 'pCO2', 'HCO3', 'Na', 'Cl', 'Alb'], compute: calcABGAAnalysis }, // New

      { id: 'ag_ratio', name: 'A/G Ratio', fields: ['TP', 'Alb'], compute: calcAGratio },
      // { id:'curb', name:'CURB-65', fields:['Confusion','BUN','RR','SBP','DBP','Age'], compute: calcCURB },
      // { id:'bsa', name:'BSA (Mosteller)', fields:['Height','Weight'], compute: calcBSA },
      // { id:'TTKG', name:'TTKG', fields:['U_K','K','U_Osm','S_Osm','U_Na'], compute: calcTTKG },
      // { id:'cairo', name:'Cairo-Bishop (TLS)', fields:['UA','K','Phos','Ca','Cr'], compute: calcTLS },
      // 추가 묶음
      // { id:'ag', name:'Anion Gap & 보정 AG', fields:['Na','Cl','HCO3','Alb'], compute: calcAG },
      // { id:'winter', name:"Winter's & ΔΔ", fields:['HCO3','pCO2','Alb','Na','Cl'], compute: calcWinter },
      // { id:'na_corr', name:'Corrected Na (Hyperglycemia)', fields:['Na','Glu'], compute: calcNaCorr },
      // { id:'osmol', name:'Serum Osm & Tonicity', fields:['Na','Glu','BUN','Ethanol','Measured_Osm'], compute: calcOsm },
      // { id:'ca_corr', name:'Corrected Calcium', fields:['Ca','Alb','iCa'], compute: calcCaCorr },
    ];

    /* ===== 수동 입력 UI 생성 (필드 사전) ===== */
    const FIELD_META = {
      Hb: { label: 'Hemoglobin', unit: 'g/dL' }, MCV: { label: 'MCV', unit: 'fL' }, RBC_mil: { label: 'RBC', unit: 'million/µL' }, RDW: { label: 'RDW', unit: '%' }, MCHC: { label: 'MCHC', unit: 'g/dL' },
      Fe: { label: 'Iron', unit: 'µg/dL' }, TIBC: { label: 'TIBC', unit: 'µg/dL' }, TSAT: { label: 'TSAT', unit: '%' }, B12: { label: 'Vitamin B12', unit: 'pg/mL' }, Folate: { label: 'Folate', unit: 'ng/mL' },
      U_Na: { label: 'Urine Na', unit: 'mEq/L' }, Na: { label: 'Serum Na', unit: 'mEq/L' }, U_Cr: { label: 'Urine Cr', unit: 'mg/dL' }, Cr: { label: 'Serum Cr', unit: 'mg/dL' },
      U_BUN: { label: 'Urine Urea N', unit: 'mg/dL' }, BUN: { label: 'BUN', unit: 'mg/dL' },
      TBil: { label: 'Total Bilirubin', unit: 'mg/dL' }, Alb: { label: 'Albumin', unit: 'g/dL' }, INR: { label: 'INR' }, Ascites: { label: 'Ascites', unit: 'grade(없음/경도/중등도)' }, Enceph: { label: 'Encephalopathy', unit: 'grade(없음/Ⅰ-Ⅱ/Ⅲ-Ⅳ)' },
      ALP: { label: 'ALP', unit: 'IU/L' }, ULN_ALP: { label: 'ULN ALP', unit: 'IU/L' }, ALT: { label: 'ALT', unit: 'IU/L' }, ULN_ALT: { label: 'ULN ALT', unit: 'IU/L' }, AST: { label: 'AST', unit: 'IU/L' }, ULN_AST: { label: 'ULN AST', unit: 'IU/L' }, GGT: { label: 'GGT', unit: 'IU/L' }, ULN_GGT: { label: 'ULN GGT', unit: 'IU/L' },
      BF_TP: { label: 'Pleural/Ascites Protein', unit: 'g/dL' }, BF_LDH: { label: 'Pleural/Ascites LDH', unit: 'IU/L' }, ULN_LDH: { label: 'Serum LDH ULN', unit: 'IU/L' }, LDH: { label: 'Serum LDH', unit: 'IU/L' }, BF_Alb: { label: 'Ascites Albumin', unit: 'g/dL' },
      HCO3: { label: 'HCO₃', unit: 'mmol/L' }, pCO2: { label: 'pCO₂', unit: 'mmHg' }, Glu: { label: 'Glucose', unit: 'mg/dL' }, Cl: { label: 'Chloride', unit: 'mEq/L' }, K: { label: 'Potassium', unit: 'mEq/L' },
      PT_sec: { label: 'PT (sec)', unit: 'sec' }, PT_control: { label: 'PT control', unit: 'sec' },
      Measured_Osm: { label: 'Measured Serum Osm', unit: 'mOsm/kg' }, Ethanol: { label: 'Ethanol', unit: 'mg/dL' }, S_Osm: { label: 'Serum Osm (calc)', unit: 'mOsm/kg' }, U_Osm: { label: 'Urine Osm', unit: 'mOsm/kg' }, U_K: { label: 'Urine K', unit: 'mEq/L' }, iCa: { label: 'Ionized Ca', unit: 'mg/dL' },
      Confusion: { label: 'Confusion', unit: '(Yes=1)' }, RR: { label: 'Respiratory Rate', unit: '/min' }, SBP: { label: 'SBP', unit: 'mmHg' }, DBP: { label: 'DBP', unit: 'mmHg' }, Age: { label: 'Age', unit: 'yr' },
      Height: { label: 'Height', unit: 'cm' }, Weight: { label: 'Weight', unit: 'kg' }, Ferritin: { label: 'Ferritin', unit: 'ng/mL' }, Reticulocyte: { label: 'Reticulocyte', unit: '%' }, Corrected_Reti: { label: 'Corrected Retic', unit: '%' }, IRF: { label: 'IRF', unit: '%' },
      UA: { label: 'Uric Acid', unit: 'mg/dL' }, Phos: { label: 'Phosphorus', unit: 'mg/dL' }, Ca: { label: 'Calcium', unit: 'mg/dL' }, Dialysis: { label: 'Dialysis (2×/week)', unit: '(Yes=1)' },
      pH: { label: 'pH' }
    };

    // === Build inputs once per calculator; don't rebuild while typing ===
    function _ensureInputs(calcId) {
      const cont = document.getElementById('calcInputsContainer'); if (!cont) return;
      if (cont.dataset.calcId === calcId && cont.childElementCount > 0) return; // already built for this calc
      cont.innerHTML = ''; cont.dataset.calcId = calcId;
      const def = CALC_DEFS.find(x => x.id === calcId); if (!def) return;
      def.fields.forEach(fid => {
        const meta = FIELD_META[fid] || { label: fid, unit: '' };
        const row = document.createElement('div'); row.className = 'calc-kv';
        const lab = document.createElement('label'); lab.textContent = `${meta.label}`;
        const inp = (fid === 'Ascites' || fid === 'Enceph') ? document.createElement('select') : document.createElement('input');
        if (fid === 'Ascites') { ['없음', '경도', '중등도'].forEach((t, i) => { const o = document.createElement('option'); o.value = String(i); o.textContent = t; inp.appendChild(o); }); }
        else if (fid === 'Enceph') { ['없음', 'I-II', 'III-IV'].forEach((t, i) => { const o = document.createElement('option'); o.value = String(i); o.textContent = t; inp.appendChild(o); }); }
        else { inp.type = 'text'; }
        inp.id = 'fld_' + fid; inp.dataset.fid = fid;

        // 사용자가 타이핑한 칸은 자동채움이 덮어쓰지 않도록 마킹
        const markEdited = () => { inp.dataset.userEdited = '1'; };
        inp.addEventListener('keydown', markEdited);
        inp.addEventListener('input', markEdited);

        // 재계산만, 재렌더(재빌드) 금지
        const recompute = () => { renderCalc(calcId, true); };
        if (inp.tagName === 'SELECT') inp.addEventListener('change', recompute);
        else inp.addEventListener('input', recompute);

        const unit = document.createElement('div'); unit.textContent = meta.unit || ''; unit.style.fontSize = '12px'; unit.style.color = '#555';
        row.appendChild(lab); row.appendChild(inp); row.appendChild(unit); cont.appendChild(row);
      });
    }

    // === Apply auto-fill to empty / non-edited fields only ===
    function _applyAutoFill(calcId) {
      const all = _collectAllForCalc();
      const def = CALC_DEFS.find(x => x.id === calcId); if (!def) return;
      def.fields.forEach(fid => {
        const el = document.getElementById('fld_' + fid); if (!el) return;
        if (el.dataset.userEdited === '1') return; // 사용자 타이핑 보존
        const v = all[fid];
        if (el.tagName === 'SELECT') {
          const sv = isFinite(v) ? String(v) : '0';
          if (el.value !== sv) el.value = sv;
        } else {
          const nv = isFinite(v) ? String(v) : (v ?? '');
          if (nv !== '' && el.value !== nv) el.value = nv;
        }
      });
    }

    function _readInputs(calcId) { const def = CALC_DEFS.find(x => x.id === calcId); const vals = {}; if (!def) return vals; def.fields.forEach(fid => { const el = document.getElementById('fld_' + fid); if (!el) return; const raw = (el.value || '').trim(); vals[fid] = (fid === 'Ascites' || fid === 'Enceph' || fid === 'Confusion' || fid === 'Dialysis') ? Number(raw || 0) : _toNum(raw); }); return vals; }

    function renderCalc(calcId, fromInput = false) {
      const reg = STATE.selectedRegno;
      const calc = _getCalcStateFor(reg);
      calc.current = calcId;

      // 입력 필드 최초 1회만 생성
      _ensureInputs(calcId);

      // 사용자 입력에서 온 호출이 아니면 자동채움(비편집 칸만)
      if (!fromInput) _applyAutoFill(calcId);

      // 값 읽어서 계산
      const def = CALC_DEFS.find(x => x.id === calcId);
      const vals = {};
      if (def) {
        def.fields.forEach(fid => {
          const el = document.getElementById('fld_' + fid);
          if (!el) { vals[fid] = NaN; return; }
          const raw = (el.value || '').trim();
          vals[fid] = (fid === 'Ascites' || fid === 'Enceph' || fid === 'Confusion' || fid === 'Dialysis') ? Number(raw || 0) : _toNum(raw);
        });
      }
      const out = def?.compute ? def.compute(vals) : { text: '미구현' };
      const el = document.getElementById('calcResult');
      if (el) {
        if (out && (out.detailsHtml || out.html)) {
          const html = out.html || (`<div><b>${out.text || ''}</b></div>` + (out.detailsHtml || ''));
          el.innerHTML = html;
        } else if (out && (out.category || out.blurb)) {
          el.innerHTML = `<div>${out.text || ''}</div>` +
            (out.category ? `<div style="margin-top:6px;"><b>${out.category}</b>${out.blurb ? ` — ${out.blurb}` : ''}</div>` : '');
        } else {
          el.textContent = out?.text || '';
        }
      }
    }

    /* ===== 계산 로직들 ===== */
    function calcAG(v) { const H = isFinite(v.HCO3) ? v.HCO3 : NaN; const AG = (v.Na - (v.Cl + H)); const AGc = isFinite(v.Alb) ? (AG + 2.5 * (4 - v.Alb)) : NaN; return { text: `AG ${_fmt(AG, 1)} / 보정 AG ${_fmt(AGc, 1)}` } }

    function calcWinter(v) {
      const H = v.HCO3; const expected = 1.5 * H + 8; const low = expected - 2, high = expected + 2; const p = v.pCO2; let msg = ''; if (isFinite(p)) { if (p < low) msg = '과보상(호흡 알칼) 의심'; else if (p > high) msg = '저보상/혼합장애 의심'; else msg = '보상 적절'; }
      // ΔΔ
      const AG = (v.Na - (v.Cl + H)); const AGc = isFinite(v.Alb) ? (AG + 2.5 * (4 - v.Alb)) : AG; const dAG = AGc - 12; const dH = 24 - H; const dd = (isFinite(dAG) && isFinite(dH) && dH !== 0) ? (dAG / dH) : NaN; let dmsg = ''; if (isFinite(dd)) { if (dd < 0.4) dmsg = '동반 정상 AG 대사성 산증'; else if (dd < 0.8) dmsg = '혼합 장애 가능'; else if (dd <= 2) dmsg = '순수 고 AG 산증에 근접'; else dmsg = '대사성 알칼 동반 의심'; }
      return { text: `Winter 예상 pCO₂ ${_fmt(expected, 1)} (범위 ${_fmt(low, 1)}~${_fmt(high, 1)}), 실제 ${_fmt(p, 1)} → ${msg}\nΔΔ = ${_fmt(dd, 2)} (${dmsg})` }
    }

    function calcABGAAnalysis(v) {
      const pH = v.pH;
      const pCO2 = v.pCO2;
      const HCO3 = v.HCO3;

      if (!isFinite(pH) || !isFinite(pCO2) || !isFinite(HCO3)) {
        return { text: "ABGA 분석을 위해 pH, pCO2, HCO3 값이 필요합니다." };
      }

      let primaryDisorder = "";
      let compensation = "";
      let anionGap = NaN;
      let correctedAnionGap = NaN;
      let deltaDelta = NaN;

      // 1. Primary Disorder
      if (pH < 7.35) { // Acidemia
        if (pCO2 > 45) { // Respiratory Acidosis
          primaryDisorder = "호흡성 산증 (Respiratory Acidosis)";
        } else if (HCO3 < 22) { // Metabolic Acidosis
          primaryDisorder = "대사성 산증 (Metabolic Acidosis)";
        } else {
          primaryDisorder = "복합 장애 (Mixed Disorder)";
        }
      } else if (pH > 7.45) { // Alkalemia
        if (pCO2 < 35) { // Respiratory Alkalosis
          primaryDisorder = "호흡성 알칼리증 (Respiratory Alkalosis)";
        } else if (HCO3 > 26) { // Metabolic Alkalosis
          primaryDisorder = "대사성 알칼리증 (Metabolic Alkalosis)";
        } else {
          primaryDisorder = "복합 장애 (Mixed Disorder)";
        }
      } else { // Normal pH
        if (pCO2 > 45 && HCO3 > 26) {
          primaryDisorder = "만성 호흡성 산증 + 대사성 알칼리증 (Chronic Respiratory Acidosis + Metabolic Alkalosis)";
        } else if (pCO2 < 35 && HCO3 < 22) {
          primaryDisorder = "만성 호흡성 알칼리증 + 대사성 산증 (Chronic Respiratory Alkalosis + Metabolic Acidosis)";
        } else {
          primaryDisorder = "정상 (Normal)";
        }
      }

      // 2. Compensation (Winter's formula for Metabolic Acidosis)
      if (primaryDisorder.includes("대사성 산증")) {
        const expectedPCO2 = (1.5 * HCO3) + 8;
        if (pCO2 < expectedPCO2 - 2) {
          compensation = "과보상 (호흡성 알칼리증 동반 의심)";
        } else if (pCO2 > expectedPCO2 + 2) {
          compensation = "저보상 (호흡성 산증 동반 의심)";
        } else {
          compensation = "적절한 보상";
        }
      }
      // Other compensations can be added here if needed

      // 3. Anion Gap (AG) and Corrected AG
      if (isFinite(v.Na) && isFinite(v.Cl)) {
        anionGap = v.Na - (v.Cl + HCO3);
        if (isFinite(v.Alb)) {
          correctedAnionGap = anionGap + 2.5 * (4 - v.Alb);
        }
      }

      // 4. Delta-Delta (for high AG Metabolic Acidosis)
      if (isFinite(correctedAnionGap) && correctedAnionGap > 12) { // Assuming normal AG is 12
        const deltaAG = correctedAnionGap - 12;
        const deltaHCO3 = 24 - HCO3; // Assuming normal HCO3 is 24
        if (isFinite(deltaHCO3) && deltaHCO3 !== 0) {
          deltaDelta = deltaAG / deltaHCO3;
        }
      }

      let deltaDeltaInterpretation = "";
      if (isFinite(deltaDelta)) {
        if (deltaDelta < 0.4) deltaDeltaInterpretation = "동반된 정상 AG 대사성 산증";
        else if (deltaDelta < 0.8) deltaDeltaInterpretation = "혼합 장애 가능성";
        else if (deltaDelta <= 2) deltaDeltaInterpretation = "순수 고 AG 대사성 산증에 근접";
        else deltaDeltaInterpretation = "동반된 대사성 알칼리증 의심";
      }

      const text = `Primary: ${primaryDisorder}\n` +
        (compensation ? `Compensation: ${compensation}\n` : '') +
        (isFinite(anionGap) ? `Anion Gap: ${_fmt(anionGap, 1)}\n` : '') +
        (isFinite(correctedAnionGap) ? `Corrected AG: ${_fmt(correctedAnionGap, 1)}\n` : '') +
        (isFinite(deltaDelta) ? `Delta-Delta: ${_fmt(deltaDelta, 2)} (${deltaDeltaInterpretation})` : '');

      const html = `<div style="font-size:13px;line-height:1.45;">` +
        `<div><b>주요 장애:</b> ${primaryDisorder}</div>` +
        (compensation ? `<div><b>보상:</b> ${compensation}</div>` : '') +
        (isFinite(anionGap) ? `<div><b>Anion Gap:</b> ${_fmt(anionGap, 1)} mEq/L</div>` : '') +
        (isFinite(correctedAnionGap) ? `<div><b>보정 Anion Gap:</b> ${_fmt(correctedAnionGap, 1)} mEq/L</div>` : '') +
        (isFinite(deltaDelta) ? `<div><b>Delta-Delta:</b> ${_fmt(deltaDelta, 2)} (${deltaDeltaInterpretation})</div>` : '');

      return { text, html };
    }

    function calcNaCorr(v) { const corr = v.Na + 1.6 * ((v.Glu - 100) / 100); return { text: `Corrected Na ${_fmt(corr, 1)} mEq/L (식: +1.6/100mg/dL)` } }

    function calcOsm(v) { const calc = 2 * v.Na + v.Glu / 18 + v.BUN / 2.8 + (isFinite(v.Ethanol) ? v.Ethanol / 3.7 : 0); const tonic = 2 * v.Na + v.Glu / 18; const gap = isFinite(v.Measured_Osm) ? (v.Measured_Osm - calc) : NaN; return { text: `Calculated Osm ${_fmt(calc, 1)} / Tonicity ${_fmt(tonic, 1)}${isFinite(gap) ? `\nOsm gap ${_fmt(gap, 1)}` : ''}` } }

    function calcCaCorr(v) { const corr = v.Ca + 0.8 * (4 - v.Alb); const note = isFinite(v.iCa) ? ` (참고: Ionized Ca ${_fmt(v.iCa, 1)})` : ''; return { text: `Corrected Ca ${_fmt(corr, 1)} mg/dL${note}` } }

    function calcRFactor(v) {
      const ALT = Number(v.ALT);
      const ALP = Number(v.ALP);
      const ULN_A = isFinite(v.ULN_ALT) ? Number(v.ULN_ALT) : 40;
      const ULN_P = isFinite(v.ULN_ALP) ? Number(v.ULN_ALP) : 120;

      let r = NaN;
      if (isFinite(ALT) && isFinite(ALP) && ULN_A > 0 && ULN_P > 0) {
        r = (ALT / ULN_A) / (ALP / ULN_P);
      }

      let clsKo = '', clsEn = '', recHtml = '';
      if (isFinite(r)) {
        if (r < 2) {
          clsKo = '담즙정체성'; clsEn = 'Cholestatic injury';
          recHtml = 'Recommend imaging studies (e.g. abdominal ultrasound)';
        } else if (r >= 5) {
          clsKo = '간세포성'; clsEn = 'Hepatocellular injury';
          recHtml = 'Recommend acute viral hepatitis serologies, HCV RNA and autoimmune hepatitis serologies, imaging studies (e.g. abdominal ultrasound)';
        } else {
          clsKo = '혼합형'; clsEn = 'Mixed injury';
          recHtml = 'Recommend acute viral hepatitis serologies, HCV RNA and autoimmune hepatitis serologies, imaging studies (e.g. abdominal ultrasound)';
        }
      }

      const text = isFinite(r) ? `R-factor ${_fmt(r, 2)} → ${clsKo}` : 'R-factor 계산 불가(입력값 확인)';
      const frac = '<span style="display:inline-block;vertical-align:middle;"><span style="display:block;text-align:center;padding:0 6px;border-bottom:1px solid #333;">(ALT ÷ ULN ALT)</span><span style="display:block;text-align:center;padding:0 6px;">(ALP ÷ ULN ALP)</span></span>';
      const html = '<div class="rf" style="font-size:13px;line-height:1.45;">' +
        '<div style="font-weight:700;">Interpretation</div>' +
        (isFinite(r) ? `<div class="muted-sm"><b>${clsEn}</b><br/>${recHtml}</div>` : '<div class="muted-sm">필요 입력: ALT, ALP (및 ULN ALT/ALP)</div>') +
        `<div style="margin-top:8px;font-weight:700;">${text}</div>` +
        '<div style="margin-top:8px;"><div style="font-weight:700;margin-bottom:4px;">Figure</div><table style="border-collapse:collapse;width:auto;min-width:320px;">' +
        '<thead><tr style="background:#f6f6f6;"><th style="text-align:left;padding:6px 8px;border:1px solid #ddd;">R Factor</th><th style="text-align:left;padding:6px 8px;border:1px solid #ddd;">Injury type</th></tr></thead>' +
        '<tbody><tr><td style="padding:6px 8px;border:1px solid #ddd;">&lt; 2</td><td style="padding:6px 8px;border:1px solid #ddd;">Cholestatic</td></tr>' +
        '<tr style="background:#fcfcfc;"><td style="padding:6px 8px;border:1px solid #ddd;">2–5</td><td style="padding:6px 8px;border:1px solid #ddd;">Mixed</td></tr>' +
        '<tr><td style="padding:6px 8px;border:1px solid #ddd;">&gt; 5</td><td style="padding:6px 8px;border:1px solid #ddd;">Hepatocellular</td></tr></tbody></table>' +
        '<div class="muted-sm" style="margin-top:8px;"><div><b>Recommended 1st line tests</b></div><ul style="margin:4px 0 0 18px;padding:0;">' +
        '<li><b>Hepatocellular or Mixed:</b> Acute viral hepatitis serologies, HCV RNA and autoimmune hepatitis serologies, imaging (e.g. abdominal ultrasound)</li>' +
        '<li><b>Cholestatic:</b> Imaging (e.g. abdominal ultrasound)</li></ul><div style="margin-top:4px;">*From Chalasani 2014.</div></div></div>' +
        '<div style="margin-top:8px;"><div style="font-weight:700;">Formula</div><div class="muted-sm">R = ' + frac + '</div>' +
        '<div class="muted-sm" style="margin-top:2px;">Note: calculator uses 40 U/L as ULN ALT and 120 U/L as ULN ALP.</div></div>' +
        '<div style="margin-top:8px;"><div style="font-weight:700;">Evidence Appraisal</div><div class="muted-sm">Introduced after a 1989 international consensus (CIOMS/RUCAM) to classify DILI patterns. Widely used and included in ACG guidelines.</div></div>' +
        '</div>';
      return { text, html };
    }

    function calcMaddrey(v) {
      const df = 4.6 * (v.PT_sec - v.PT_control) + v.TBil;
      const prog = isFinite(df) ? (df >= 32 ? 'Poor prognosis' : 'Good prognosis') : '';
      const text = `Maddrey DF : ${_fmt(df, 1)} points`;

      const html =
        `<div style="font-size:13px;line-height:1.35;">` +
        `<div><b>${text}</b></div>` +
        (prog ? `<div>${prog}</div>` : ``) +
        `<div style="margin-top:4px;"><b>Discriminant Function</b></div>` +
        `<div class="muted-sm">&gt;32 points indicates poor prognosis and patient may benefit from glucocorticoid therapy.</div>` +
        `</div>`;

      return { text, html };
    }

    function calcAGratio(v) { const glob = v.TP - v.Alb; const agr = v.Alb / glob; const flag = (isFinite(agr) && agr < 1) ? ' (A/G<1)' : ''; return { text: `Globulin ${_fmt(glob, 1)} g/dL, A/G ${_fmt(agr, 1)}${flag}` } }

    function calcFENa(v) {
      const fe = 100 * (v.U_Na * v.Cr) / (v.Na * v.U_Cr);
      let label = '';
      if (isFinite(fe)) {
        if (fe < 1) label = 'Prerenal';
        else if (fe <= 2) label = 'Indeterminate';
        else label = 'Intrinsic';
      }
      const text = `FENa ${_fmt(fe, 1)} %${label ? ' — ' + label : ''}`;

      // 결과에 해당하는 설명만 선택
      const explainMap = {
        Prerenal: 'e.g., Hypovolemia, heart failure, renal artery stenosis, sepsis (anything causing decreased effective renal perfusion). Remember, contrast-induced nephropathy will often look pre-renal.',
        Indeterminate: 'Can be seen with either prerenal or intrinsic states.',
        Intrinsic: 'e.g., ATN, AIN, glomerulonephritides.'
      };
      const catHtml = label
        ? `<div style="margin-top:6px;"><span style="font-weight:700;">${label}</span> <span class="muted-sm">— ${explainMap[label]}</span></div>`
        : '';

      // 컴팩트 레이아웃 + Formula 분수 표기 + Facts&Figures를 Pearls 위로
      const html =
        '<div class="fenacard" style="font-size:13px;line-height:1.45;">'
        + '<div style="font-weight:700;">' + text + '</div>'
        + catHtml
        + '<div style="margin-top:8px;display:grid;grid-template-columns:1fr 1fr;gap:8px;">'
        + '<div>'
        + '<div style="font-weight:700;">When to use</div>'
        + '<div class="muted-sm">Patients with oliguria and/or acute kidney injury of unclear etiology.</div>'
        + '</div>'
        + '<div>'
        + '<div style="font-weight:700;">Formula</div>'
        +       // FENa (%) = 100 ×  (SCr×UNa)/(SNa×UCr)  → 분수 스타일
        +       '<div class="muted-sm" style="display:flex;align-items:center;gap:6px;">'
        + '<span>FENa (%) = 100 ×</span>'
        + '<span style="display:inline-block;text-align:center;line-height:1.15;">'
        + '<span style="display:block;border-bottom:1px solid #999;padding:0 4px;">SCr × UNa</span>'
        + '<span style="display:block;padding-top:1px;">SNa × UCr</span>'
        + '</span>'
        + '</div>'
        + '</div>'
        + '</div>'
        // === Facts & Figures (위로 이동) ===
        + '<div style="margin-top:8px;">'
        + '<div style="font-weight:700;">Facts &amp; Figures</div>'
        + '<table style="border-collapse:collapse;margin-top:4px;">'
        + '<thead>'
        + '<tr>'
        + '<th style="text-align:left;padding:2px 6px;border-bottom:1px solid #ddd;"></th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">Prerenal</th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">Indeterminate</th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">Intrinsic</th>'
        + '</tr>'
        + '</thead>'
        + '<tbody>'
        + '<tr><td style="padding:2px 6px;">FENa</td><td style="text-align:center;padding:2px 6px;">&lt;1%</td><td style="text-align:center;padding:2px 6px;">1–2%</td><td style="text-align:center;padding:2px 6px;">&gt;2%</td></tr>'
        + '<tr><td style="padding:2px 6px;">UNa (mmol/L)</td><td style="text-align:center;padding:2px 6px;">&lt;20</td><td style="text-align:center;padding:2px 6px;">20–40</td><td style="text-align:center;padding:2px 6px;">&gt;40</td></tr>'
        + '</tbody>'
        + '</table>'
        + '</div>'
        // === Pearls / Pitfalls (아래로 이동) ===
        + '<div style="margin-top:8px;">'
        + '<div style="font-weight:700;">Pearls / Pitfalls</div>'
        + '<ul style="margin:4px 0 0 18px;padding:0;">'
        + '<li>Clinically validated only in oliguric AKI without diuretics, CKD, obstruction, or acute glomerular disease.</li>'
        + '<li>Urine sodium alone is less accurate; it ignores urine volume and ADH-mediated water handling.</li>'
        + '<li>Single SCr values are snapshots and may not reflect true GFR.</li>'
        + '<li>In patients with liver disease, FENa &lt;1% does not reliably distinguish etiology.</li>'
        + '</ul>'
        + '</div>'
        + '</div>';

      return { text, html, category: label };
    }

    function calcFEUrea(v) {
      const fe = 100 * (v.U_BUN * v.Cr) / (v.BUN * v.U_Cr);
      let hint = '';
      if (isFinite(fe)) {
        if (fe > 35) hint = 'FEUrea >35% suggests intrinsic renal disease';
        else if (fe < 35) hint = 'FEUrea <35% suggests pre-renal disease';
        else hint = 'FEUrea 35% (cutoff): interpret with clinical context';
      }

      const text = `FEUrea ${_fmt(fe, 1)} %${hint ? ' — ' + hint : ''}`;

      // 표(Facts & Figures) → Pearls → Formula(분수표현만) 순서
      const html =
        '<div class="feurea" style="font-size:13px;line-height:1.45;">'
        + '<div style="font-weight:700;">' + text + '</div>'

        // Facts & Figures (TOP)
        + '<div style="margin-top:8px;">'
        + '<div style="font-weight:700;">Facts &amp; Figures</div>'
        + '<div class="muted-sm" style="margin-top:2px;">This test can provide similar information to the FENa equation, but can still be used in patients on diuretic therapy (diuretics alter the sodium concentration, making the FENa equation unusable).</div>'
        + '<table style="border-collapse:collapse;margin-top:4px;">'
        + '<thead>'
        + '<tr>'
        + '<th style="text-align:left;padding:2px 6px;border-bottom:1px solid #ddd;"></th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">Prerenal</th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">Intrinsic renal</th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">Postrenal</th>'
        + '</tr>'
        + '</thead>'
        + '<tbody>'
        + '<tr><td style="padding:2px 6px;">FENa</td><td style="text-align:center;padding:2px 6px;">&lt;1%</td><td style="text-align:center;padding:2px 6px;">&gt;1%</td><td style="text-align:center;padding:2px 6px;">&gt;4%</td></tr>'
        + '<tr><td style="padding:2px 6px;">FEUrea</td><td style="text-align:center;padding:2px 6px;">&le; 35%</td><td style="text-align:center;padding:2px 6px;">&gt;50%</td><td style="text-align:center;padding:2px 6px;">N/A</td></tr>'
        + '</tbody>'
        + '</table>'
        + '</div>'

        // Pearls
        + '<div style="margin-top:8px;">'
        + '<div style="font-weight:700;">Pearls</div>'
        + '<div class="muted-sm">While lesser known than FENa, the FEUrea can be used in patients on diuretics, since urea excretion is not significantly affected by diuretics.</div>'
        + '</div>'

        // Formula (fraction-only; remove plain text line)
        + '<div style="margin-top:8px;">'
        + '<div style="font-weight:700;">Formula</div>'
        + '<div class="muted-sm" aria-hidden="true" style="margin-top:2px;">FEUrea (%) = 100 × '
        + '<span style="display:inline-block;vertical-align:middle;">'
        + '<span style="display:block;border-bottom:1px solid #999;padding:0 4px;text-align:center;">SerumCr × UUrea</span>'
        + '<span style="display:block;padding:0 4px;text-align:center;">SerumUrea × UCr</span>'
        + '</span>'
        + '</div>'
        + '</div>'
        + '</div>';

      return { text, html };
    }

    function calcTTKG(v) { const t = (v.U_K * v.S_Osm) / (v.K * v.U_Osm); let warn = ''; if (!(v.U_Na >= 25)) warn += '[주의: U-Na<25] '; if (!(v.U_Osm > v.S_Osm)) warn += '[주의: U-Osm ≤ S-Osm]'; return { text: `TTKG ${_fmt(t, 1)} ${warn}` } }

    function calcLights(v) { const rP = v.BF_TP / v.TP; const rL = v.BF_LDH / v.LDH; const thr = (2 / 3) * v.ULN_LDH; const meet = (rP > 0.5) || (rL > 0.6) || (v.BF_LDH > thr); const label = meet ? 'Exudate' : 'Transudate'; return { text: `Protein ratio ${_fmt(rP, 2)}, LDH ratio ${_fmt(rL, 2)}, Pleural LDH ${_fmt(v.BF_LDH, 0)} vs 2/3×ULN ${_fmt(thr, 0)} → ${label}` } }

    function calcSAAG(v) { const s = v.Alb - v.BF_Alb; const msg = (isFinite(s) && s >= 1.1) ? '문맥고혈증 시사(≥1.1)' : '비문맥 원인 가능'; return { text: `SAAG ${_fmt(s, 2)} → ${msg}` } }

    function calcChildPugh(v) { // Ascites: 0없음/1경도/2중등도 ; Enceph: 0없음/1 I-II/2 III-IV
      const b = isFinite(v.TBil) ? (v.TBil < 2 ? 1 : (v.TBil <= 3 ? 2 : 3)) : 0;
      const a = isFinite(v.Alb) ? (v.Alb > 3.5 ? 1 : (v.Alb >= 2.8 ? 2 : 3)) : 0;
      const i = isFinite(v.INR) ? (v.INR < 1.7 ? 1 : (v.INR <= 2.3 ? 2 : 3)) : 0; // INR 기준
      // Ascites는 3단계(없음/경도/중등도). 0/1/2 → 1/2/3점으로 매핑
      const asc = (v.Ascites === 0 || v.Ascites === 1 || v.Ascites === 2)
        ? (Number(v.Ascites) + 1)
        : (isFinite(v.Ascites) && v.Ascites >= 2 ? 3 : 0);
      // Enceph: 0/1/2 → 1/2/3점
      const enc = Number(v.Enceph || 0) + 1;

      const sum = b + a + i + asc + enc;
      const cls = (sum <= 6 ? 'A' : (sum <= 9 ? 'B' : 'C'));
      const text = `Child-Pugh ${_fmt(sum, 0)}점 (Class ${cls})`;

      // 클래스별 해석 문구
      let interpHtml = '';
      if (cls === 'C') {
        interpHtml = '<b>Child Class C</b><br/>Life Expectancy : 1-3 years<br/>Abdominal surgery peri-operative mortality: 82%';
      } else if (cls === 'B') {
        interpHtml = '<b>Child Class B</b><br/>Indication for transplant evaluation<br/>Abdominal surgery peri-operative mortality: 30%';
      } else {
        interpHtml = '<b>Child Class A</b><br/>Life Expectancy : 15-20 years<br/>Abdominal surgery peri-operative mortality: 10%';
      }

      // Interpretation(최상단) + 점수/클래스 + Figure(채점표/컷오프) + Facts & Figures
      const html =
        '<div class="cpc" style="font-size:13px;line-height:1.45;">'
        // Interpretation 먼저
        + '<div style="font-weight:700;">Interpretation</div>'
        + '<div class="muted-sm">' + interpHtml + '</div>'
        // 점수/클래스 제목
        + '<div style="margin-top:8px;font-weight:700;">' + text + '</div>'
        // Figure
        + '<div style="margin-top:8px;">'
        + '<div style="font-weight:700;">Figure</div>'
        + '<table style="border-collapse:collapse;margin-top:4px;">'
        + '<thead><tr>'
        + '<th style="text-align:left;padding:2px 6px;border-bottom:1px solid #ddd;">Criterion</th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">1 pt</th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">2 pt</th>'
        + '<th style="text-align:center;padding:2px 6px;border-bottom:1px solid #ddd;">3 pt</th>'
        + '</tr></thead>'
        + '<tbody>'
        + '<tr><td style="padding:2px 6px;">Total bilirubin (mg/dL)</td><td style="text-align:center;padding:2px 6px;">&lt; 2</td><td style="text-align:center;padding:2px 6px;">2–3</td><td style="text-align:center;padding:2px 6px;">&gt; 3</td></tr>'
        + '<tr><td style="padding:2px 6px;">Albumin (g/dL)</td><td style="text-align:center;padding:2px 6px;">&gt; 3.5</td><td style="text-align:center;padding:2px 6px;">2.8–3.5</td><td style="text-align:center;padding:2px 6px;">&lt; 2.8</td></tr>'
        + '<tr><td style="padding:2px 6px;">INR</td><td style="text-align:center;padding:2px 6px;">&lt; 1.7</td><td style="text-align:center;padding:2px 6px;">1.7–2.3</td><td style="text-align:center;padding:2px 6px;">&gt; 2.3</td></tr>'
        + '<tr><td style="padding:2px 6px;">Ascites</td><td style="text-align:center;padding:2px 6px;">None</td><td style="text-align:center;padding:2px 6px;">Slight</td><td style="text-align:center;padding:2px 6px;">Moderate</td></tr>'
        + '<tr><td style="padding:2px 6px;">Encephalopathy</td><td style="text-align:center;padding:2px 6px;">None</td><td style="text-align:center;padding:2px 6px;">Gr I–II</td><td style="text-align:center;padding:2px 6px;">Gr III–IV</td></tr>'
        + '</tbody>'
        + '</table>'
        + '<table style="border-collapse:collapse;margin-top:6px;">'
        + '<tbody>'
        + '<tr><td style="padding:2px 6px;font-weight:700;border-bottom:1px solid #ddd;">Class</td><td style="padding:2px 6px;font-weight:700;border-bottom:1px solid #ddd;text-align:center;">Score</td></tr>'
        + '<tr><td style="padding:2px 6px;">A</td><td style="padding:2px 6px;text-align:center;">5–6</td></tr>'
        + '<tr><td style="padding:2px 6px;">B</td><td style="padding:2px 6px;text-align:center;">7–9</td></tr>'
        + '<tr><td style="padding:2px 6px;">C</td><td style="padding:2px 6px;text-align:center;">≥ 10</td></tr>'
        + '</tbody>'
        + '</table>'
        + '</div>'
        // Facts & Figures (FDA grades)
        + '<div style="margin-top:8px;">'
        + '<div style="font-weight:700;">Facts &amp; Figures</div>'
        + '<div class="muted-sm" style="margin:2px 0 4px;">Encephalopathy Grades (from the FDA)</div>'
        + '<ul class="muted-sm" style="margin:0 0 0 18px;padding:0;">'
        + '<li>Grade 0: normal consciousness, personality, neurological examination, electroencephalogram</li>'
        + '<li>Grade 1: restless, sleep disturbed, irritable/agitated, tremor, impaired handwriting, 5 cps waves</li>'
        + '<li>Grade 2: lethargic, time-disoriented, inappropriate, asterixis, ataxia, slow triphasic waves</li>'
        + '<li>Grade 3: somnolent, stuporous, place-disoriented, hyperactive reflexes, rigidity, slower waves</li>'
        + '<li>Grade 4: unrousable coma, no personality/behavior, decerebrate, slow 2-3 cps delta activity</li>'
        + '</ul>'
        + '</div>'
        + '</div>';

      return { text, html };
    }

    function calcMELD(v) { // MELD-Na 기본
      const Cr = Math.min(Math.max(v.Cr, 1), 4); const Bil = Math.max(v.TBil, 1); const INR = Math.max(v.INR, 1); let Na = v.Na; if (!isFinite(Na)) Na = 137; Na = Math.max(Math.min(Na, 137), 125); const base = 0.957 * _lnCap(Cr) + 0.378 * _lnCap(Bil) + 1.12 * _lnCap(INR) + 0.643; const dial = (Number(v.Dialysis || 0) >= 1) ? 4.0 : Cr; const meldi = 0.957 * _lnCap(dial) + 0.378 * _lnCap(Bil) + 1.12 * _lnCap(INR) + 0.643; const meldNa = meldi + 1.32 * (137 - Na) - 0.033 * meldi * (137 - Na); return { text: `MELD-Na ${Math.round(meldNa)} (기본 MELD ${Math.round(meldi)})` }
    }

    function calcCURB(v) { // Confusion(1/0), Urea mmol/L (=BUN/2.8), RR>=30, SBP<90 or DBP<=60, Age>=65
      const u = v.BUN / 2.8; let s = 0; if (v.Confusion >= 1) s++; if (isFinite(u) && u > 7) s++; if (isFinite(v.RR) && v.RR >= 30) s++; if ((isFinite(v.SBP) && v.SBP < 90) || (isFinite(v.DBP) && v.DBP <= 60)) s++; if (isFinite(v.Age) && v.Age >= 65) s++; let risk = s <= 1 ? '저위험' : s === 2 ? '중등도' : '고위험'; return { text: `CURB-65 ${s}점 → ${risk}` }
    }

    function calcBSA(v) { const bsa = Math.sqrt((v.Height * v.Weight) / 3600); return { text: `BSA ${_fmt(bsa, 2)} m² (Mosteller)` } }

    function calcTLS(v) { const hits = []; if (isFinite(v.UA) && v.UA >= 8) hits.push('UA≥8'); if (isFinite(v.K) && v.K >= 6) hits.push('K≥6'); if (isFinite(v.Phos) && v.Phos >= 4.5) hits.push('Phos≥4.5'); if (isFinite(v.Ca) && v.Ca <= 7) hits.push('Ca≤7'); const labTLS = hits.length >= 2; return { text: `TLS 기준: ${hits.join(', ') || '해당 없음'} → ${labTLS ? '랩 TLS 충족 가능' : '랩 TLS 불충족'}` } }

    function calcAnemia(v) {
      // 0) 입력 결합: 사용자가 넣은 v 우선, 부족하면 화면 상태에서 보충
      const a = Object.assign({}, _collectAllForCalc(), v || {});

      // 1) 파생 지표/플래그
      const micro = isFinite(a.MCV) && a.MCV < 80;
      const macro = isFinite(a.MCV) && a.MCV > 100;
      const normo = isFinite(a.MCV) && !micro && !macro;

      const mentzer = (isFinite(a.MCV) && isFinite(a.RBC_mil) && a.RBC_mil > 0)
        ? (a.MCV / a.RBC_mil) : NaN;

      const tsat = isFinite(a.TSAT) ? a.TSAT
        : (isFinite(a.Fe) && isFinite(a.TIBC) && a.TIBC > 0 ? (100 * a.Fe / a.TIBC) : NaN);

      const indBil = (isFinite(a.TBil) && isFinite(a.DBil)) ? (a.TBil - a.DBil) : NaN;
      const ldhHigh = isFinite(a.LDH) && ((isFinite(a.ULN_LDH) && a.LDH > a.ULN_LDH) || a.LDH > 250);

      const crpHigh = isFinite(a.CRP) && a.CRP > 1.0;
      const crHigh = isFinite(a.Cr) && a.Cr > 1.5;

      const reticRaw = isFinite(a.Corrected_Reti) ? a.Corrected_Reti : a.Reticulocyte; // 교정값 우선
      const hasRetic = isFinite(reticRaw);
      const isReticHigh = hasRetic && reticRaw > 2.5;   // 교정/비교정 공통 임계 2.5%
      const irfHigh = isFinite(a.IRF) && a.IRF > 12; // IRF>12% → 스트레스 조혈

      const severeAnemia = isFinite(a.Hb) && a.Hb < 8;
      const isPancytopenic = (isFinite(a.WBC) && a.WBC < 3000) && (isFinite(a.Plt) && a.Plt < 100000);

      const ferritinLow = isFinite(a.Ferritin) && a.Ferritin < 30;
      const ferritinHigh = isFinite(a.Ferritin) && a.Ferritin > 100;

      // 2) 출력 버킷
      const basics = [], alerts = [], findings = [], diffs = [], recs = [];

      // 3) 기본 수치 요약
      basics.push('[기본 수치]');
      if (isFinite(a.Hb)) basics.push(`- Hb ${_fmt(a.Hb, 1)} g/dL${severeAnemia ? ' (Severe)' : (a.Hb < 10 ? ' (Moderate)' : (a.Hb < 12 ? ' (Mild)' : ''))}`);
      if (isFinite(a.MCV)) basics.push(`- MCV ${_fmt(a.MCV, 1)} fL`);
      if (isFinite(a.RDW)) basics.push(`- RDW ${_fmt(a.RDW, 1)} %`);
      if (isFinite(a.RBC_mil)) basics.push(`- RBC ${_fmt(a.RBC_mil, 2)} ×10⁶/µL`);
      if (isFinite(mentzer)) basics.push(`- Mentzer index ${_fmt(mentzer, 1)}`);
      if (isFinite(tsat)) basics.push(`- TSAT ${_fmt(tsat, 1)} %`);
      if (isFinite(a.Ferritin)) basics.push(`- Ferritin ${_fmt(a.Ferritin, 0)} ng/mL`);
      if (isFinite(a.Cr)) basics.push(`- Cr ${_fmt(a.Cr, 2)} mg/dL`);
      if (isFinite(a.CRP)) basics.push(`- CRP ${_fmt(a.CRP, 1)} mg/dL`);
      if (isFinite(a.LDH)) basics.push(`- LDH ${_fmt(a.LDH, 0)} IU/L${isFinite(a.ULN_LDH) ? ` (ULN ${_fmt(a.ULN_LDH, 0)})` : ''}`);
      if (isFinite(a.TBil)) basics.push(`- TBil ${_fmt(a.TBil, 1)} mg/dL${isFinite(indBil) ? ` (Indirect ${_fmt(indBil, 1)})` : ''}`);
      if (hasRetic) basics.push(`- Reticulocyte ${_fmt(reticRaw, 2)} %${isFinite(a.Corrected_Reti) ? ' (corrected)' : ''}`);
      if (isFinite(a.IRF)) basics.push(`- IRF ${_fmt(a.IRF, 1)} %`);

      // 4) 전역 경고
      if (isPancytopenic) {
        alerts.push('⚠️ 범혈구감소증: 즉시 혈액종양내과 평가(급성백혈병/재생불량성 빈혈/MDS 등) 고려');
        findings.push(`- 백혈구 감소(${_fmt(a.WBC, 0)}/µL), 혈소판 감소(${_fmt(a.Plt, 0)}/µL) 동반`);
        recs.push('- 말초도말(PBS), 말초분획(Diff), 용혈지표, 골수검사 조기 의뢰');
      }
      if (severeAnemia) {
        alerts.push('⚠️ 중증 빈혈(Hb < 8): 증상/기저질환 고려해 수혈 적응증 평가');
      }

      // 5) 망상적혈구/IRF 분기 → 파괴/손실 vs 생산저하
      if (isReticHigh || irfHigh) {
        findings.push('- 망상적혈구 증가/IRF 상승: 파괴·소실(용혈/출혈) 패턴');
        diffs.push('- 용혈성 빈혈', '- 출혈(급성/만성)');

        if (ldhHigh || (isFinite(indBil) && indBil > 0.7)) {
          findings.push('- LDH↑ 또는 간접빌리루빈↑ 동반 → 용혈 지지');
          recs.push('- Haptoglobin(↓), DAT(Direct Coombs), PBS(구상/분열적혈구), 소변 Hb/hemosiderin');
        }
        recs.push('- 임상적 출혈원(위장관/부인과/수술부위 등) 확인');

        // 추가 힌트(동시 소구/대구 소견)
        if (micro && isFinite(mentzer) && mentzer < 13) {
          diffs.push('- 지중해빈혈(Thalassemia trait) 가능 (Mentzer < 13)');
          recs.push('- Hb 전기영동/유전자 검사(철결핍 교정 후) 고려');
        }
      } else {
        // retic 없음/정상 → 생산저하 접근
        if (hasRetic) findings.push('- 망상적혈구 정상/감소: 생산 저하(골수 반응 부적절) 양상');
        else { findings.push('- 망상적혈구 결과 없음: 생산 저하 가능성 우선 추정'); recs.push('- Reticulocyte(교정치) 및 IRF 측정 권고'); }

        if (micro) {
          findings.push('- 소구성 빈혈 패턴');
          if (isFinite(mentzer) && mentzer < 13) {
            diffs.push('- 지중해빈혈(Thalassemia trait) 우선 의심');
            recs.push('- Hb 전기영동/유전자 검사 (철결핍 교정 후 시행)');
          } else {
            if (ferritinLow) {
              diffs.push('- 철결핍성 빈혈(IDA)');
              recs.push('- 잠재 출혈원(위장관/월경과다 등) 평가, Iron profile 재확인');
            } else if (ferritinHigh && isFinite(tsat) && tsat < 20) {
              diffs.push('- 만성질환/염증성 빈혈(ACD/AI) 가능성↑');
              recs.push('- CRP/ESR, Transferrin(↓) 확인');
            } else if (isFinite(a.Ferritin) && a.Ferritin >= 30 && a.Ferritin <= 100) {
              diffs.push('- 혼합성(IDA+염증) 또는 초기 결핍 가능');
              recs.push('- TSAT<20%면 IDA 쪽 가중, Ferritin 추적');
            } else {
              diffs.push('- 철대사 이상(IDA/ACD) 또는 유전성 소구성 빈혈 가능');
            }
          }
          if (crpHigh) findings.push(`- CRP ${_fmt(a.CRP, 1)} ↑ → 염증 동반 시사`);

        } else if (macro) {
          findings.push('- 대구성 빈혈 패턴');
          diffs.push('- 비타민 B12/엽산 결핍', '- 골수이형성증후군(MDS)', '- 간질환/알코올', '- 약물');
          if (ldhHigh) findings.push('- LDH 상승 → 무효조혈(특히 B12 결핍) 가능');
          if (isFinite(a.B12) && a.B12 < 200) findings.push(`- B12 저하(${_fmt(a.B12, 0)} pg/mL)`);
          if (isFinite(a.Folate) && a.Folate < 4) findings.push(`- Folate 저하(${_fmt(a.Folate, 1)} ng/mL)`);
          recs.push('- B12, Folate, TSH, 간기능, 약물력 확인 ± PBS(과분엽 호중구)');
        } else if (normo) {
          findings.push('- 정구성 빈혈 패턴');
          if (crHigh) {
            diffs.push('- 만성신질환 빈혈(Anemia of CKD)');
            recs.push('- eGFR 산출, 필요 시 EPO 결핍 평가');
          }
          if (crpHigh) {
            diffs.push('- 만성질환/염증성 빈혈(ACD/AI)');
          }
          if (isFinite(a.RDW) && a.RDW > 15) {
            diffs.push('- 초기/혼합 영양결핍 가능');
            recs.push('- Ferritin, B12, Folate 동시 확인');
          }
        }
      }

      // 6) 최종 출력
      const uniq = (arr) => Array.from(new Set(arr.filter(Boolean)));
      const sections = [
        basics.join('\n'),
        alerts.length ? ['[경고]', ...uniq(alerts)].join('\n') : '',
        findings.length ? ['[핵심 소견]', ...uniq(findings)].join('\n') : '',
        diffs.length ? ['[가능성 높은 감별]', ...uniq(diffs)].join('\n') : '',
        recs.length ? ['[추가 검사/대응]', ...uniq(recs)].join('\n') : ''
      ].filter(Boolean);

      return { text: sections.join('\n\n') };
    }

    /* ===== 모달 열기/닫기 & 렌더 ===== */
    function openCalcModal() {
      const m = document.getElementById('calcModal'); if (!m) return; m.classList.add('show');
      const reg = STATE.selectedRegno;
      const p = STATE.patients.get(reg) || STATE.prevDocPatients.get(reg);
      const calc = _getCalcStateFor(reg);

      // ULN 스캔: 추가 Lab 텍스트 우선, 없으면 신규 Lab에서만
      (function () {
        const pasted = [calc.serumText, calc.abgaText, calc.urineText, calc.fluidText].filter(Boolean).join('\n');
        const src = pasted && pasted.trim() ? pasted : (p?.newRaw || '');
        calc.uln = _scanULNFromNewLab(src);
      })();

      // 좌측 계산기 목록
      const list = document.getElementById('calcList');
      if (list) {
        list.innerHTML = '';
        CALC_DEFS.forEach((d, i) => {
          const b = document.createElement('button');
          b.className = 'calc-item' + ((calc.current ? (calc.current === d.id) : (i === 0)) ? ' active' : '');
          b.textContent = d.name; b.dataset.id = d.id;
          b.onclick = () => {
            list.querySelectorAll('.calc-item').forEach(n => n.classList.remove('active'));
            b.classList.add('active');
            renderCalc(d.id);
          };
          list.appendChild(b);
        });
      }

      // 탭 동작
      const tabs = m.querySelectorAll('.tabbar .tab');
      tabs.forEach(tb => {
        tb.onclick = () => {
          tabs.forEach(x => x.classList.remove('active'));
          tb.classList.add('active');
          const id = tb.dataset.tab;
          document.getElementById('calcSerumText').style.display = (id === 'serum') ? 'block' : 'none';
          document.getElementById('calcAbgaText').style.display = (id === 'abga') ? 'block' : 'none';
          document.getElementById('calcUrineText').style.display = (id === 'urine') ? 'block' : 'none';
          document.getElementById('calcFluidText').style.display = (id === 'fluid') ? 'block' : 'none';
        };
      });

      // 사용자 붙여넣기 텍스트 (자동 시드 금지, 저장된 환자별 값만 복원)
      const elSer = document.getElementById('calcSerumText');
      const elAbg = document.getElementById('calcAbgaText');
      const elUri = document.getElementById('calcUrineText');
      const elFlu = document.getElementById('calcFluidText');
      if (elSer) elSer.value = calc.serumText || '';
      if (elAbg) elAbg.value = calc.abgaText || '';
      if (elUri) elUri.value = calc.urineText || '';
      if (elFlu) elFlu.value = calc.fluidText || '';

      // 자동 파싱(debounce)
      let t = null;
      const doParse = () => {
        calc.serumText = elSer ? (elSer.value || '') : '';
        calc.abgaText = elAbg ? (elAbg.value || '') : '';
        calc.urineText = elUri ? (elUri.value || '') : '';
        calc.fluidText = elFlu ? (elFlu.value || '') : '';
        calc.serum = _parseSerumToCalc(calc.serumText);
        calc.abga = _parseABGA(calc.abgaText);
        calc.urine = _parseUrine(calc.urineText);
        calc.fluid = _parseFluid(calc.fluidText);
        // ULN은 serumText에서 발견되면 갱신
        const ulnNow = _scanULNFromNewLab(calc.serumText || '');
        calc.uln = Object.assign({}, calc.uln, ulnNow);
        renderCalc(calc.current || (CALC_DEFS[0]?.id));
      };
      const bind = (el) => {
        if (!el) return;
        el.removeEventListener('input', el._calc_inp_handler || (() => { }));
        const h = () => { if (t) clearTimeout(t); t = setTimeout(doParse, 120); };
        el.addEventListener('input', h); el._calc_inp_handler = h;
      };
      bind(elSer); bind(elAbg); bind(elUri); bind(elFlu);

      // 최초 렌더(저장값 기준)
      renderCalc(calc.current || (CALC_DEFS[0]?.id));

      // 모달 내부 UX 보조
      attachProxyWheelToTextareas(m);
      if (elSer) bindAutoGrow(elSer);
      if (elAbg) bindAutoGrow(elAbg);
      if (elUri) bindAutoGrow(elUri);
      if (elFlu) bindAutoGrow(elFlu);
    }

    function closeCalcModal() { const m = document.getElementById('calcModal'); if (m) m.classList.remove('show'); }

    document.getElementById('btnCalc').addEventListener('click', openCalcModal);
    document.getElementById('btnCloseCalc').addEventListener('click', closeCalcModal);

    // Apply auto-grow to mini inputs
    ['diagText', 'vsText', 'c4Text', 'c5Text'].forEach(id => {
      const el = document.getElementById(id);
      if (el) bindAutoGrow(el);
    });

  </script>
</body>

</html>